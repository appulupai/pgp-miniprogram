{"version":3,"sources":["compiler-ssr.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerDom = require('@vue/compiler-dom');\nvar shared = require('@vue/shared');\n\nconst SSR_INTERPOLATE = Symbol(`ssrInterpolate`);\nconst SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);\nconst SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);\nconst SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);\nconst SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`);\nconst SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);\nconst SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);\nconst SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);\nconst SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);\nconst SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);\nconst SSR_RENDER_LIST = Symbol(`ssrRenderList`);\nconst SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);\nconst SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);\nconst SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);\nconst SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);\nconst SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);\nconst SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);\nconst SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);\nconst SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);\nconst ssrHelpers = {\n    [SSR_INTERPOLATE]: `ssrInterpolate`,\n    [SSR_RENDER_VNODE]: `ssrRenderVNode`,\n    [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\n    [SSR_RENDER_SLOT]: `ssrRenderSlot`,\n    [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,\n    [SSR_RENDER_CLASS]: `ssrRenderClass`,\n    [SSR_RENDER_STYLE]: `ssrRenderStyle`,\n    [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\n    [SSR_RENDER_ATTR]: `ssrRenderAttr`,\n    [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\n    [SSR_RENDER_LIST]: `ssrRenderList`,\n    [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\n    [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\n    [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\n    [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\n    [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\n    [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\n    [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\n    [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`\n};\n// Note: these are helpers imported from @vue/server-renderer\n// make sure the names match!\ncompilerDom.registerRuntimeHelpers(ssrHelpers);\n\n// Plugin for the first transform pass, which simply constructs the AST node\nconst ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);\n// This is called during the 2nd transform pass to construct the SSR-specific\n// codegen nodes.\nfunction ssrProcessIf(node, context, disableNestedFragments = false) {\n    const [rootBranch] = node.branches;\n    const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));\n    context.pushStatement(ifStatement);\n    let currentIf = ifStatement;\n    for (let i = 1; i < node.branches.length; i++) {\n        const branch = node.branches[i];\n        const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);\n        if (branch.condition) {\n            // else-if\n            currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);\n        }\n        else {\n            // else\n            currentIf.alternate = branchBlockStatement;\n        }\n    }\n    if (!currentIf.alternate) {\n        currentIf.alternate = compilerDom.createBlockStatement([\n            compilerDom.createCallExpression(`_push`, ['`<!---->`'])\n        ]);\n    }\n}\nfunction processIfBranch(branch, context, disableNestedFragments = false) {\n    const { children } = branch;\n    const needFragmentWrapper = !disableNestedFragments &&\n        (children.length !== 1 || children[0].type !== 1 /* NodeTypes.ELEMENT */) &&\n        // optimize away nested fragments when the only child is a ForNode\n        !(children.length === 1 && children[0].type === 11 /* NodeTypes.FOR */);\n    return processChildrenAsStatement(branch, context, needFragmentWrapper);\n}\n\n// Plugin for the first transform pass, which simply constructs the AST node\nconst ssrTransformFor = compilerDom.createStructuralDirectiveTransform('for', compilerDom.processFor);\n// This is called during the 2nd transform pass to construct the SSR-specific\n// codegen nodes.\nfunction ssrProcessFor(node, context, disableNestedFragments = false) {\n    const needFragmentWrapper = !disableNestedFragments &&\n        (node.children.length !== 1 || node.children[0].type !== 1 /* NodeTypes.ELEMENT */);\n    const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node.parseResult));\n    renderLoop.body = processChildrenAsStatement(node, context, needFragmentWrapper);\n    // v-for always renders a fragment unless explicitly disabled\n    if (!disableNestedFragments) {\n        context.pushStringPart(`<!--[-->`);\n    }\n    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [\n        node.source,\n        renderLoop\n    ]));\n    if (!disableNestedFragments) {\n        context.pushStringPart(`<!--]-->`);\n    }\n}\n\nconst ssrTransformSlotOutlet = (node, context) => {\n    if (compilerDom.isSlotOutlet(node)) {\n        const { slotName, slotProps } = compilerDom.processSlotOutlet(node, context);\n        const args = [\n            `_ctx.$slots`,\n            slotName,\n            slotProps || `{}`,\n            // fallback content placeholder. will be replaced in the process phase\n            `null`,\n            `_push`,\n            `_parent`\n        ];\n        // inject slot scope id if current template uses :slotted\n        if (context.scopeId && context.slotted !== false) {\n            args.push(`\"${context.scopeId}-s\"`);\n        }\n        let method = SSR_RENDER_SLOT;\n        // #3989\n        // check if this is a single slot inside a transition wrapper - since\n        // transition will unwrap the slot fragment into a single vnode at runtime,\n        // we need to avoid rendering the slot as a fragment.\n        const parent = context.parent;\n        if (parent &&\n            parent.type === 1 /* NodeTypes.ELEMENT */ &&\n            parent.tagType === 1 /* ElementTypes.COMPONENT */ &&\n            compilerDom.resolveComponentType(parent, context, true) === compilerDom.TRANSITION &&\n            parent.children.filter(c => c.type === 1 /* NodeTypes.ELEMENT */).length === 1) {\n            method = SSR_RENDER_SLOT_INNER;\n            if (!(context.scopeId && context.slotted !== false)) {\n                args.push('null');\n            }\n            args.push('true');\n        }\n        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(method), args);\n    }\n};\nfunction ssrProcessSlotOutlet(node, context) {\n    const renderCall = node.ssrCodegenNode;\n    // has fallback content\n    if (node.children.length) {\n        const fallbackRenderFn = compilerDom.createFunctionExpression([]);\n        fallbackRenderFn.body = processChildrenAsStatement(node, context);\n        // _renderSlot(slots, name, props, fallback, ...)\n        renderCall.arguments[3] = fallbackRenderFn;\n    }\n    // Forwarded <slot/>. Merge slot scope ids\n    if (context.withSlotScopeId) {\n        const slotScopeId = renderCall.arguments[6];\n        renderCall.arguments[6] = slotScopeId\n            ? `${slotScopeId} + _scopeId`\n            : `_scopeId`;\n    }\n    context.pushStatement(node.ssrCodegenNode);\n}\n\nfunction createSSRCompilerError(code, loc) {\n    return compilerDom.createCompilerError(code, loc, SSRErrorMessages);\n}\nconst SSRErrorMessages = {\n    [61 /* SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME */]: `Unsafe attribute name for SSR.`,\n    [62 /* SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET */]: `Missing the 'to' prop on teleport element.`,\n    [63 /* SSRErrorCodes.X_SSR_INVALID_AST_NODE */]: `Invalid AST node during SSR transform.`\n};\n\n// Note: this is a 2nd-pass codegen transform.\nfunction ssrProcessTeleport(node, context) {\n    const targetProp = compilerDom.findProp(node, 'to');\n    if (!targetProp) {\n        context.onError(createSSRCompilerError(62 /* SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET */, node.loc));\n        return;\n    }\n    let target;\n    if (targetProp.type === 6 /* NodeTypes.ATTRIBUTE */) {\n        target =\n            targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);\n    }\n    else {\n        target = targetProp.exp;\n    }\n    if (!target) {\n        context.onError(createSSRCompilerError(62 /* SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET */, targetProp.loc));\n        return;\n    }\n    const disabledProp = compilerDom.findProp(node, 'disabled', false, true /* allow empty */);\n    const disabled = disabledProp\n        ? disabledProp.type === 6 /* NodeTypes.ATTRIBUTE */\n            ? `true`\n            : disabledProp.exp || `false`\n        : `false`;\n    const contentRenderFn = compilerDom.createFunctionExpression([`_push`], undefined, // Body is added later\n    true, // newline\n    false, // isSlot\n    node.loc);\n    contentRenderFn.body = processChildrenAsStatement(node, context);\n    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [\n        `_push`,\n        contentRenderFn,\n        target,\n        disabled,\n        `_parent`\n    ]));\n}\n\nconst wipMap = new WeakMap();\n// phase 1\nfunction ssrTransformSuspense(node, context) {\n    return () => {\n        if (node.children.length) {\n            const wipEntry = {\n                slotsExp: null,\n                wipSlots: []\n            };\n            wipMap.set(node, wipEntry);\n            wipEntry.slotsExp = compilerDom.buildSlots(node, context, (_props, children, loc) => {\n                const fn = compilerDom.createFunctionExpression([], undefined, // no return, assign body later\n                true, // newline\n                false, // suspense slots are not treated as normal slots\n                loc);\n                wipEntry.wipSlots.push({\n                    fn,\n                    children\n                });\n                return fn;\n            }).slots;\n        }\n    };\n}\n// phase 2\nfunction ssrProcessSuspense(node, context) {\n    // complete wip slots with ssr code\n    const wipEntry = wipMap.get(node);\n    if (!wipEntry) {\n        return;\n    }\n    const { slotsExp, wipSlots } = wipEntry;\n    for (let i = 0; i < wipSlots.length; i++) {\n        const slot = wipSlots[i];\n        slot.fn.body = processChildrenAsStatement(slot, context);\n    }\n    // _push(ssrRenderSuspense(slots))\n    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [\n        `_push`,\n        slotsExp\n    ]));\n}\n\n// for directives with children overwrite (e.g. v-html & v-text), we need to\n// store the raw children so that they can be added in the 2nd pass.\nconst rawChildrenMap = new WeakMap();\nconst ssrTransformElement = (node, context) => {\n    if (node.type !== 1 /* NodeTypes.ELEMENT */ ||\n        node.tagType !== 0 /* ElementTypes.ELEMENT */) {\n        return;\n    }\n    return function ssrPostTransformElement() {\n        // element\n        // generate the template literal representing the open tag.\n        const openTag = [`<${node.tag}`];\n        // some tags need to be passed to runtime for special checks\n        const needTagForRuntime = node.tag === 'textarea' || node.tag.indexOf('-') > 0;\n        // v-bind=\"obj\", v-bind:[key] and custom directives can potentially\n        // overwrite other static attrs and can affect final rendering result,\n        // so when they are present we need to bail out to full `renderAttrs`\n        const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);\n        const hasCustomDir = node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && !shared.isBuiltInDirective(p.name));\n        const needMergeProps = hasDynamicVBind || hasCustomDir;\n        if (needMergeProps) {\n            const { props, directives } = compilerDom.buildProps(node, context, node.props, false /* isComponent */, false /* isDynamicComponent */, true /* ssr */);\n            if (props || directives.length) {\n                const mergedProps = buildSSRProps(props, directives, context);\n                const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [mergedProps]);\n                if (node.tag === 'textarea') {\n                    const existingText = node.children[0];\n                    // If interpolation, this is dynamic <textarea> content, potentially\n                    // injected by v-model and takes higher priority than v-bind value\n                    if (!existingText || existingText.type !== 5 /* NodeTypes.INTERPOLATION */) {\n                        // <textarea> with dynamic v-bind. We don't know if the final props\n                        // will contain .value, so we will have to do something special:\n                        // assign the merged props to a temp variable, and check whether\n                        // it contains value (if yes, render is as children).\n                        const tempId = `_temp${context.temps++}`;\n                        propsExp.arguments = [\n                            compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), mergedProps)\n                        ];\n                        rawChildrenMap.set(node, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [\n                            compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`\"value\" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)\n                        ]));\n                    }\n                }\n                else if (node.tag === 'input') {\n                    // <input v-bind=\"obj\" v-model>\n                    // we need to determine the props to render for the dynamic v-model\n                    // and merge it with the v-bind expression.\n                    const vModel = findVModel(node);\n                    if (vModel) {\n                        // 1. save the props (san v-model) in a temp variable\n                        const tempId = `_temp${context.temps++}`;\n                        const tempExp = compilerDom.createSimpleExpression(tempId, false);\n                        propsExp.arguments = [\n                            compilerDom.createSequenceExpression([\n                                compilerDom.createAssignmentExpression(tempExp, mergedProps),\n                                compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [\n                                    tempExp,\n                                    compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [\n                                        tempExp,\n                                        vModel.exp // model\n                                    ])\n                                ])\n                            ])\n                        ];\n                    }\n                }\n                if (needTagForRuntime) {\n                    propsExp.arguments.push(`\"${node.tag}\"`);\n                }\n                openTag.push(propsExp);\n            }\n        }\n        // book keeping static/dynamic class merging.\n        let dynamicClassBinding = undefined;\n        let staticClassBinding = undefined;\n        // all style bindings are converted to dynamic by transformStyle.\n        // but we need to make sure to merge them.\n        let dynamicStyleBinding = undefined;\n        for (let i = 0; i < node.props.length; i++) {\n            const prop = node.props[i];\n            // ignore true-value/false-value on input\n            if (node.tag === 'input' && isTrueFalseValue(prop)) {\n                continue;\n            }\n            // special cases with children override\n            if (prop.type === 7 /* NodeTypes.DIRECTIVE */) {\n                if (prop.name === 'html' && prop.exp) {\n                    rawChildrenMap.set(node, prop.exp);\n                }\n                else if (prop.name === 'text' && prop.exp) {\n                    node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\n                }\n                else if (prop.name === 'slot') {\n                    context.onError(compilerDom.createCompilerError(40 /* ErrorCodes.X_V_SLOT_MISPLACED */, prop.loc));\n                }\n                else if (isTextareaWithValue(node, prop) && prop.exp) {\n                    if (!needMergeProps) {\n                        node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\n                    }\n                }\n                else if (!needMergeProps && prop.name !== 'on') {\n                    // Directive transforms.\n                    const directiveTransform = context.directiveTransforms[prop.name];\n                    if (directiveTransform) {\n                        const { props, ssrTagParts } = directiveTransform(prop, node, context);\n                        if (ssrTagParts) {\n                            openTag.push(...ssrTagParts);\n                        }\n                        for (let j = 0; j < props.length; j++) {\n                            const { key, value } = props[j];\n                            if (compilerDom.isStaticExp(key)) {\n                                let attrName = key.content;\n                                // static key attr\n                                if (attrName === 'key' || attrName === 'ref') {\n                                    continue;\n                                }\n                                if (attrName === 'class') {\n                                    openTag.push(` class=\"`, (dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value])), `\"`);\n                                }\n                                else if (attrName === 'style') {\n                                    if (dynamicStyleBinding) {\n                                        // already has style binding, merge into it.\n                                        mergeCall(dynamicStyleBinding, value);\n                                    }\n                                    else {\n                                        openTag.push(` style=\"`, (dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value])), `\"`);\n                                    }\n                                }\n                                else {\n                                    attrName =\n                                        node.tag.indexOf('-') > 0\n                                            ? attrName // preserve raw name on custom elements\n                                            : shared.propsToAttrMap[attrName] || attrName.toLowerCase();\n                                    if (shared.isBooleanAttr(attrName)) {\n                                        openTag.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), compilerDom.createSimpleExpression(' ' + attrName, true), compilerDom.createSimpleExpression('', true), false /* no newline */));\n                                    }\n                                    else if (shared.isSSRSafeAttrName(attrName)) {\n                                        openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [\n                                            key,\n                                            value\n                                        ]));\n                                    }\n                                    else {\n                                        context.onError(createSSRCompilerError(61 /* SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME */, key.loc));\n                                    }\n                                }\n                            }\n                            else {\n                                // dynamic key attr\n                                // this branch is only encountered for custom directive\n                                // transforms that returns properties with dynamic keys\n                                const args = [key, value];\n                                if (needTagForRuntime) {\n                                    args.push(`\"${node.tag}\"`);\n                                }\n                                openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                // special case: value on <textarea>\n                if (node.tag === 'textarea' && prop.name === 'value' && prop.value) {\n                    rawChildrenMap.set(node, shared.escapeHtml(prop.value.content));\n                }\n                else if (!needMergeProps) {\n                    if (prop.name === 'key' || prop.name === 'ref') {\n                        continue;\n                    }\n                    // static prop\n                    if (prop.name === 'class' && prop.value) {\n                        staticClassBinding = JSON.stringify(prop.value.content);\n                    }\n                    openTag.push(` ${prop.name}` +\n                        (prop.value ? `=\"${shared.escapeHtml(prop.value.content)}\"` : ``));\n                }\n            }\n        }\n        // handle co-existence of dynamic + static class bindings\n        if (dynamicClassBinding && staticClassBinding) {\n            mergeCall(dynamicClassBinding, staticClassBinding);\n            removeStaticBinding(openTag, 'class');\n        }\n        if (context.scopeId) {\n            openTag.push(` ${context.scopeId}`);\n        }\n        node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);\n    };\n};\nfunction buildSSRProps(props, directives, context) {\n    let mergePropsArgs = [];\n    if (props) {\n        if (props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n            // already a mergeProps call\n            mergePropsArgs = props.arguments;\n        }\n        else {\n            mergePropsArgs.push(props);\n        }\n    }\n    if (directives.length) {\n        for (const dir of directives) {\n            mergePropsArgs.push(compilerDom.createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [\n                `_ctx`,\n                ...compilerDom.buildDirectiveArgs(dir, context).elements\n            ]));\n        }\n    }\n    return mergePropsArgs.length > 1\n        ? compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), mergePropsArgs)\n        : mergePropsArgs[0];\n}\nfunction isTrueFalseValue(prop) {\n    if (prop.type === 7 /* NodeTypes.DIRECTIVE */) {\n        return (prop.name === 'bind' &&\n            prop.arg &&\n            compilerDom.isStaticExp(prop.arg) &&\n            (prop.arg.content === 'true-value' || prop.arg.content === 'false-value'));\n    }\n    else {\n        return prop.name === 'true-value' || prop.name === 'false-value';\n    }\n}\nfunction isTextareaWithValue(node, prop) {\n    return !!(node.tag === 'textarea' &&\n        prop.name === 'bind' &&\n        compilerDom.isStaticArgOf(prop.arg, 'value'));\n}\nfunction mergeCall(call, arg) {\n    const existing = call.arguments[0];\n    if (existing.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */) {\n        existing.elements.push(arg);\n    }\n    else {\n        call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);\n    }\n}\nfunction removeStaticBinding(tag, binding) {\n    const regExp = new RegExp(`^ ${binding}=\".+\"$`);\n    const i = tag.findIndex(e => typeof e === 'string' && regExp.test(e));\n    if (i > -1) {\n        tag.splice(i, 1);\n    }\n}\nfunction findVModel(node) {\n    return node.props.find(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'model' && p.exp);\n}\nfunction ssrProcessElement(node, context) {\n    const isVoidTag = context.options.isVoidTag || shared.NO;\n    const elementsToAdd = node.ssrCodegenNode.elements;\n    for (let j = 0; j < elementsToAdd.length; j++) {\n        context.pushStringPart(elementsToAdd[j]);\n    }\n    // Handle slot scopeId\n    if (context.withSlotScopeId) {\n        context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));\n    }\n    // close open tag\n    context.pushStringPart(`>`);\n    const rawChildren = rawChildrenMap.get(node);\n    if (rawChildren) {\n        context.pushStringPart(rawChildren);\n    }\n    else if (node.children.length) {\n        processChildren(node, context);\n    }\n    if (!isVoidTag(node.tag)) {\n        // push closing tag\n        context.pushStringPart(`</${node.tag}>`);\n    }\n}\n\nconst wipMap$1 = new WeakMap();\n// phase 1: build props\nfunction ssrTransformTransitionGroup(node, context) {\n    return () => {\n        const tag = compilerDom.findProp(node, 'tag');\n        if (tag) {\n            const otherProps = node.props.filter(p => p !== tag);\n            const { props, directives } = compilerDom.buildProps(node, context, otherProps, true /* isComponent */, false /* isDynamicComponent */, true /* ssr (skip event listeners) */);\n            let propsExp = null;\n            if (props || directives.length) {\n                propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [\n                    buildSSRProps(props, directives, context)\n                ]);\n            }\n            wipMap$1.set(node, {\n                tag,\n                propsExp\n            });\n        }\n    };\n}\n// phase 2: process children\nfunction ssrProcessTransitionGroup(node, context) {\n    const entry = wipMap$1.get(node);\n    if (entry) {\n        const { tag, propsExp } = entry;\n        if (tag.type === 7 /* NodeTypes.DIRECTIVE */) {\n            // dynamic :tag\n            context.pushStringPart(`<`);\n            context.pushStringPart(tag.exp);\n            if (propsExp) {\n                context.pushStringPart(propsExp);\n            }\n            context.pushStringPart(`>`);\n            processChildren(node, context, false, \n            /**\n             * TransitionGroup has the special runtime behavior of flattening and\n             * concatenating all children into a single fragment (in order for them to\n             * be patched using the same key map) so we need to account for that here\n             * by disabling nested fragment wrappers from being generated.\n             */\n            true);\n            context.pushStringPart(`</`);\n            context.pushStringPart(tag.exp);\n            context.pushStringPart(`>`);\n        }\n        else {\n            // static tag\n            context.pushStringPart(`<${tag.value.content}`);\n            if (propsExp) {\n                context.pushStringPart(propsExp);\n            }\n            context.pushStringPart(`>`);\n            processChildren(node, context, false, true);\n            context.pushStringPart(`</${tag.value.content}>`);\n        }\n    }\n    else {\n        // fragment\n        processChildren(node, context, true, true);\n    }\n}\n\n// We need to construct the slot functions in the 1st pass to ensure proper\n// scope tracking, but the children of each slot cannot be processed until\n// the 2nd pass, so we store the WIP slot functions in a weakMap during the 1st\n// pass and complete them in the 2nd pass.\nconst wipMap$2 = new WeakMap();\nconst WIP_SLOT = Symbol();\nconst componentTypeMap = new WeakMap();\n// ssr component transform is done in two phases:\n// In phase 1. we use `buildSlot` to analyze the children of the component into\n// WIP slot functions (it must be done in phase 1 because `buildSlot` relies on\n// the core transform context).\n// In phase 2. we convert the WIP slots from phase 1 into ssr-specific codegen\n// nodes.\nconst ssrTransformComponent = (node, context) => {\n    if (node.type !== 1 /* NodeTypes.ELEMENT */ ||\n        node.tagType !== 1 /* ElementTypes.COMPONENT */) {\n        return;\n    }\n    const component = compilerDom.resolveComponentType(node, context, true /* ssr */);\n    const isDynamicComponent = shared.isObject(component) && component.callee === compilerDom.RESOLVE_DYNAMIC_COMPONENT;\n    componentTypeMap.set(node, component);\n    if (shared.isSymbol(component)) {\n        if (component === compilerDom.SUSPENSE) {\n            return ssrTransformSuspense(node, context);\n        }\n        if (component === compilerDom.TRANSITION_GROUP) {\n            return ssrTransformTransitionGroup(node, context);\n        }\n        return; // other built-in components: fallthrough\n    }\n    // Build the fallback vnode-based branch for the component's slots.\n    // We need to clone the node into a fresh copy and use the buildSlots' logic\n    // to get access to the children of each slot. We then compile them with\n    // a child transform pipeline using vnode-based transforms (instead of ssr-\n    // based ones), and save the result branch (a ReturnStatement) in an array.\n    // The branch is retrieved when processing slots again in ssr mode.\n    const vnodeBranches = [];\n    const clonedNode = clone(node);\n    return function ssrPostTransformComponent() {\n        // Using the cloned node, build the normal VNode-based branches (for\n        // fallback in case the child is render-fn based). Store them in an array\n        // for later use.\n        if (clonedNode.children.length) {\n            compilerDom.buildSlots(clonedNode, context, (props, children) => {\n                vnodeBranches.push(createVNodeSlotBranch(props, children, context));\n                return compilerDom.createFunctionExpression(undefined);\n            });\n        }\n        let propsExp = `null`;\n        if (node.props.length) {\n            // note we are not passing ssr: true here because for components, v-on\n            // handlers should still be passed\n            const { props, directives } = compilerDom.buildProps(node, context, undefined, true, isDynamicComponent);\n            if (props || directives.length) {\n                propsExp = buildSSRProps(props, directives, context);\n            }\n        }\n        const wipEntries = [];\n        wipMap$2.set(node, wipEntries);\n        const buildSSRSlotFn = (props, children, loc) => {\n            const fn = compilerDom.createFunctionExpression([props || `_`, `_push`, `_parent`, `_scopeId`], undefined, // no return, assign body later\n            true, // newline\n            true, // isSlot\n            loc);\n            wipEntries.push({\n                type: WIP_SLOT,\n                fn,\n                children,\n                // also collect the corresponding vnode branch built earlier\n                vnodeBranch: vnodeBranches[wipEntries.length]\n            });\n            return fn;\n        };\n        const slots = node.children.length\n            ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots\n            : `null`;\n        if (typeof component !== 'string') {\n            // dynamic component that resolved to a `resolveDynamicComponent` call\n            // expression - since the resolved result may be a plain element (string)\n            // or a VNode, handle it with `renderVNode`.\n            node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [\n                `_push`,\n                compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [\n                    component,\n                    propsExp,\n                    slots\n                ]),\n                `_parent`\n            ]);\n        }\n        else {\n            node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, propsExp, slots, `_parent`]);\n        }\n    };\n};\nfunction ssrProcessComponent(node, context, parent) {\n    const component = componentTypeMap.get(node);\n    if (!node.ssrCodegenNode) {\n        // this is a built-in component that fell-through.\n        if (component === compilerDom.TELEPORT) {\n            return ssrProcessTeleport(node, context);\n        }\n        else if (component === compilerDom.SUSPENSE) {\n            return ssrProcessSuspense(node, context);\n        }\n        else if (component === compilerDom.TRANSITION_GROUP) {\n            return ssrProcessTransitionGroup(node, context);\n        }\n        else {\n            // real fall-through: Transition / KeepAlive\n            // just render its children.\n            // #5352: if is at root level of a slot, push an empty string.\n            // this does not affect the final output, but avoids all-comment slot\n            // content of being treated as empty by ssrRenderSlot().\n            if (parent.type === WIP_SLOT) {\n                context.pushStringPart(``);\n            }\n            // #5351: filter out comment children inside transition\n            if (component === compilerDom.TRANSITION) {\n                node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */);\n            }\n            processChildren(node, context);\n        }\n    }\n    else {\n        // finish up slot function expressions from the 1st pass.\n        const wipEntries = wipMap$2.get(node) || [];\n        for (let i = 0; i < wipEntries.length; i++) {\n            const { fn, vnodeBranch } = wipEntries[i];\n            // For each slot, we generate two branches: one SSR-optimized branch and\n            // one normal vnode-based branch. The branches are taken based on the\n            // presence of the 2nd `_push` argument (which is only present if the slot\n            // is called by `_ssrRenderSlot`.\n            fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(wipEntries[i], context, false, true /* withSlotScopeId */), vnodeBranch);\n        }\n        // component is inside a slot, inherit slot scope Id\n        if (context.withSlotScopeId) {\n            node.ssrCodegenNode.arguments.push(`_scopeId`);\n        }\n        if (typeof component === 'string') {\n            // static component\n            context.pushStatement(compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode]));\n        }\n        else {\n            // dynamic component (`resolveDynamicComponent` call)\n            // the codegen node is a `renderVNode` call\n            context.pushStatement(node.ssrCodegenNode);\n        }\n    }\n}\nconst rawOptionsMap = new WeakMap();\nconst [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];\nconst vnodeDirectiveTransforms = {\n    ...baseDirectiveTransforms,\n    ...compilerDom.DOMDirectiveTransforms\n};\nfunction createVNodeSlotBranch(props, children, parentContext) {\n    // apply a sub-transform using vnode-based transforms.\n    const rawOptions = rawOptionsMap.get(parentContext.root);\n    const subOptions = {\n        ...rawOptions,\n        // overwrite with vnode-based transforms\n        nodeTransforms: [\n            ...vnodeNodeTransforms,\n            ...(rawOptions.nodeTransforms || [])\n        ],\n        directiveTransforms: {\n            ...vnodeDirectiveTransforms,\n            ...(rawOptions.directiveTransforms || {})\n        }\n    };\n    // wrap the children with a wrapper template for proper children treatment.\n    const wrapperNode = {\n        type: 1 /* NodeTypes.ELEMENT */,\n        ns: 0 /* Namespaces.HTML */,\n        tag: 'template',\n        tagType: 3 /* ElementTypes.TEMPLATE */,\n        isSelfClosing: false,\n        // important: provide v-slot=\"props\" on the wrapper for proper\n        // scope analysis\n        props: [\n            {\n                type: 7 /* NodeTypes.DIRECTIVE */,\n                name: 'slot',\n                exp: props,\n                arg: undefined,\n                modifiers: [],\n                loc: compilerDom.locStub\n            }\n        ],\n        children,\n        loc: compilerDom.locStub,\n        codegenNode: undefined\n    };\n    subTransform(wrapperNode, subOptions, parentContext);\n    return compilerDom.createReturnStatement(children);\n}\nfunction subTransform(node, options, parentContext) {\n    const childRoot = compilerDom.createRoot([node]);\n    const childContext = compilerDom.createTransformContext(childRoot, options);\n    // this sub transform is for vnode fallback branch so it should be handled\n    // like normal render functions\n    childContext.ssr = false;\n    // inherit parent scope analysis state\n    childContext.scopes = { ...parentContext.scopes };\n    childContext.identifiers = { ...parentContext.identifiers };\n    childContext.imports = parentContext.imports;\n    // traverse\n    compilerDom.traverseNode(childRoot, childContext);\n    ['helpers', 'components', 'directives'].forEach(key => {\n        childContext[key].forEach((value, helperKey) => {\n            if (key === 'helpers') {\n                const parentCount = parentContext.helpers.get(helperKey);\n                if (parentCount === undefined) {\n                    parentContext.helpers.set(helperKey, value);\n                }\n                else {\n                    parentContext.helpers.set(helperKey, value + parentCount);\n                }\n            }\n            else {\n                parentContext[key].add(value);\n            }\n        });\n    });\n    // imports/hoists are not merged because:\n    // - imports are only used for asset urls and should be consistent between\n    //   node/client branches\n    // - hoists are not enabled for the client branch here\n}\nfunction clone(v) {\n    if (shared.isArray(v)) {\n        return v.map(clone);\n    }\n    else if (shared.isObject(v)) {\n        const res = {};\n        for (const key in v) {\n            res[key] = clone(v[key]);\n        }\n        return res;\n    }\n    else {\n        return v;\n    }\n}\n\n// Because SSR codegen output is completely different from client-side output\n// (e.g. multiple elements can be concatenated into a single template literal\n// instead of each getting a corresponding call), we need to apply an extra\n// transform pass to convert the template AST into a fresh JS AST before\n// passing it to codegen.\nfunction ssrCodegenTransform(ast, options) {\n    const context = createSSRTransformContext(ast, options);\n    // inject SFC <style> CSS variables\n    // we do this instead of inlining the expression to ensure the vars are\n    // only resolved once per render\n    if (options.ssrCssVars) {\n        const cssContext = compilerDom.createTransformContext(compilerDom.createRoot([]), options);\n        const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options.ssrCssVars, false), cssContext);\n        context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));\n        Array.from(cssContext.helpers.keys()).forEach(helper => {\n            if (!ast.helpers.includes(helper))\n                ast.helpers.push(helper);\n        });\n    }\n    const isFragment = ast.children.length > 1 && ast.children.some(c => !compilerDom.isText(c));\n    processChildren(ast, context, isFragment);\n    ast.codegenNode = compilerDom.createBlockStatement(context.body);\n    // Finalize helpers.\n    // We need to separate helpers imported from 'vue' vs. '@vue/server-renderer'\n    ast.ssrHelpers = Array.from(new Set([...ast.helpers.filter(h => h in ssrHelpers), ...context.helpers]));\n    ast.helpers = ast.helpers.filter(h => !(h in ssrHelpers));\n}\nfunction createSSRTransformContext(root, options, helpers = new Set(), withSlotScopeId = false) {\n    const body = [];\n    let currentString = null;\n    return {\n        root,\n        options,\n        body,\n        helpers,\n        withSlotScopeId,\n        onError: options.onError ||\n            (e => {\n                throw e;\n            }),\n        helper(name) {\n            helpers.add(name);\n            return name;\n        },\n        pushStringPart(part) {\n            if (!currentString) {\n                const currentCall = compilerDom.createCallExpression(`_push`);\n                body.push(currentCall);\n                currentString = compilerDom.createTemplateLiteral([]);\n                currentCall.arguments.push(currentString);\n            }\n            const bufferedElements = currentString.elements;\n            const lastItem = bufferedElements[bufferedElements.length - 1];\n            if (shared.isString(part) && shared.isString(lastItem)) {\n                bufferedElements[bufferedElements.length - 1] += part;\n            }\n            else {\n                bufferedElements.push(part);\n            }\n        },\n        pushStatement(statement) {\n            // close current string\n            currentString = null;\n            body.push(statement);\n        }\n    };\n}\nfunction createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {\n    // ensure child inherits parent helpers\n    return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);\n}\nfunction processChildren(parent, context, asFragment = false, disableNestedFragments = false) {\n    if (asFragment) {\n        context.pushStringPart(`<!--[-->`);\n    }\n    const { children } = parent;\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case 1 /* NodeTypes.ELEMENT */:\n                switch (child.tagType) {\n                    case 0 /* ElementTypes.ELEMENT */:\n                        ssrProcessElement(child, context);\n                        break;\n                    case 1 /* ElementTypes.COMPONENT */:\n                        ssrProcessComponent(child, context, parent);\n                        break;\n                    case 2 /* ElementTypes.SLOT */:\n                        ssrProcessSlotOutlet(child, context);\n                        break;\n                    case 3 /* ElementTypes.TEMPLATE */:\n                        // TODO\n                        break;\n                    default:\n                        context.onError(createSSRCompilerError(63 /* SSRErrorCodes.X_SSR_INVALID_AST_NODE */, child.loc));\n                        // make sure we exhaust all possible types\n                        const exhaustiveCheck = child;\n                        return exhaustiveCheck;\n                }\n                break;\n            case 2 /* NodeTypes.TEXT */:\n                context.pushStringPart(shared.escapeHtml(child.content));\n                break;\n            case 3 /* NodeTypes.COMMENT */:\n                // no need to escape comment here because the AST can only\n                // contain valid comments.\n                context.pushStringPart(`<!--${child.content}-->`);\n                break;\n            case 5 /* NodeTypes.INTERPOLATION */:\n                context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));\n                break;\n            case 9 /* NodeTypes.IF */:\n                ssrProcessIf(child, context, disableNestedFragments);\n                break;\n            case 11 /* NodeTypes.FOR */:\n                ssrProcessFor(child, context, disableNestedFragments);\n                break;\n            case 10 /* NodeTypes.IF_BRANCH */:\n                // no-op - handled by ssrProcessIf\n                break;\n            case 12 /* NodeTypes.TEXT_CALL */:\n            case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n                // no-op - these two types can never appear as template child node since\n                // `transformText` is not used during SSR compile.\n                break;\n            default:\n                context.onError(createSSRCompilerError(63 /* SSRErrorCodes.X_SSR_INVALID_AST_NODE */, child.loc));\n                // make sure we exhaust all possible types\n                const exhaustiveCheck = child;\n                return exhaustiveCheck;\n        }\n    }\n    if (asFragment) {\n        context.pushStringPart(`<!--]-->`);\n    }\n}\nfunction processChildrenAsStatement(parent, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {\n    const childContext = createChildContext(parentContext, withSlotScopeId);\n    processChildren(parent, childContext, asFragment);\n    return compilerDom.createBlockStatement(childContext.body);\n}\n\nconst ssrTransformModel = (dir, node, context) => {\n    const model = dir.exp;\n    function checkDuplicatedValue() {\n        const value = compilerDom.findProp(node, 'value');\n        if (value) {\n            context.onError(compilerDom.createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\n        }\n    }\n    if (node.tagType === 0 /* ElementTypes.ELEMENT */) {\n        const res = { props: [] };\n        const defaultProps = [\n            // default value binding for text type inputs\n            compilerDom.createObjectProperty(`value`, model)\n        ];\n        if (node.tag === 'input') {\n            const type = compilerDom.findProp(node, 'type');\n            if (type) {\n                const value = findValueBinding(node);\n                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {\n                    // dynamic type\n                    res.ssrTagParts = [\n                        compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [\n                            type.exp,\n                            model,\n                            value\n                        ])\n                    ];\n                }\n                else if (type.value) {\n                    // static type\n                    switch (type.value.content) {\n                        case 'radio':\n                            res.props = [\n                                compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                                    model,\n                                    value\n                                ]))\n                            ];\n                            break;\n                        case 'checkbox':\n                            const trueValueBinding = compilerDom.findProp(node, 'true-value');\n                            if (trueValueBinding) {\n                                const trueValue = trueValueBinding.type === 6 /* NodeTypes.ATTRIBUTE */\n                                    ? JSON.stringify(trueValueBinding.value.content)\n                                    : trueValueBinding.exp;\n                                res.props = [\n                                    compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                                        model,\n                                        trueValue\n                                    ]))\n                                ];\n                            }\n                            else {\n                                res.props = [\n                                    compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\n                                        model,\n                                        value\n                                    ]), model))\n                                ];\n                            }\n                            break;\n                        case 'file':\n                            context.onError(compilerDom.createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\n                            break;\n                        default:\n                            checkDuplicatedValue();\n                            res.props = defaultProps;\n                            break;\n                    }\n                }\n            }\n            else if (compilerDom.hasDynamicKeyVBind(node)) ;\n            else {\n                // text type\n                checkDuplicatedValue();\n                res.props = defaultProps;\n            }\n        }\n        else if (node.tag === 'textarea') {\n            checkDuplicatedValue();\n            node.children = [compilerDom.createInterpolation(model, model.loc)];\n        }\n        else if (node.tag === 'select') ;\n        else {\n            context.onError(compilerDom.createDOMCompilerError(54 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\n        }\n        return res;\n    }\n    else {\n        // component v-model\n        return compilerDom.transformModel(dir, node, context);\n    }\n};\nfunction findValueBinding(node) {\n    const valueBinding = compilerDom.findProp(node, 'value');\n    return valueBinding\n        ? valueBinding.type === 7 /* NodeTypes.DIRECTIVE */\n            ? valueBinding.exp\n            : compilerDom.createSimpleExpression(valueBinding.value.content, true)\n        : compilerDom.createSimpleExpression(`null`, false);\n}\n\nconst ssrTransformShow = (dir, node, context) => {\n    if (!dir.exp) {\n        context.onError(compilerDom.createDOMCompilerError(58 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */));\n    }\n    return {\n        props: [\n            compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(dir.exp, compilerDom.createSimpleExpression(`null`, false), compilerDom.createObjectExpression([\n                compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))\n            ]), false /* no newline */))\n        ]\n    };\n};\n\nconst filterChild = (node) => node.children.filter(n => n.type !== 3 /* NodeTypes.COMMENT */);\nconst hasSingleChild = (node) => filterChild(node).length === 1;\nconst ssrInjectFallthroughAttrs = (node, context) => {\n    // _attrs is provided as a function argument.\n    // mark it as a known identifier so that it doesn't get prefixed by\n    // transformExpression.\n    if (node.type === 0 /* NodeTypes.ROOT */) {\n        context.identifiers._attrs = 1;\n    }\n    if (node.type === 1 /* NodeTypes.ELEMENT */ &&\n        node.tagType === 1 /* ElementTypes.COMPONENT */ &&\n        (compilerDom.isBuiltInType(node.tag, 'Transition') ||\n            compilerDom.isBuiltInType(node.tag, 'KeepAlive'))) {\n        const rootChildren = filterChild(context.root);\n        if (rootChildren.length === 1 && rootChildren[0] === node) {\n            if (hasSingleChild(node)) {\n                injectFallthroughAttrs(node.children[0]);\n            }\n            return;\n        }\n    }\n    const parent = context.parent;\n    if (!parent || parent.type !== 0 /* NodeTypes.ROOT */) {\n        return;\n    }\n    if (node.type === 10 /* NodeTypes.IF_BRANCH */ && hasSingleChild(node)) {\n        // detect cases where the parent v-if is not the only root level node\n        let hasEncounteredIf = false;\n        for (const c of filterChild(parent)) {\n            if (c.type === 9 /* NodeTypes.IF */ ||\n                (c.type === 1 /* NodeTypes.ELEMENT */ && compilerDom.findDir(c, 'if'))) {\n                // multiple root v-if\n                if (hasEncounteredIf)\n                    return;\n                hasEncounteredIf = true;\n            }\n            else if (\n            // node before v-if\n            !hasEncounteredIf ||\n                // non else nodes\n                !(c.type === 1 /* NodeTypes.ELEMENT */ && compilerDom.findDir(c, /else/, true))) {\n                return;\n            }\n        }\n        injectFallthroughAttrs(node.children[0]);\n    }\n    else if (hasSingleChild(parent)) {\n        injectFallthroughAttrs(node);\n    }\n};\nfunction injectFallthroughAttrs(node) {\n    if (node.type === 1 /* NodeTypes.ELEMENT */ &&\n        (node.tagType === 0 /* ElementTypes.ELEMENT */ ||\n            node.tagType === 1 /* ElementTypes.COMPONENT */) &&\n        !compilerDom.findDir(node, 'for')) {\n        node.props.push({\n            type: 7 /* NodeTypes.DIRECTIVE */,\n            name: 'bind',\n            arg: undefined,\n            exp: compilerDom.createSimpleExpression(`_attrs`, false),\n            modifiers: [],\n            loc: compilerDom.locStub\n        });\n    }\n}\n\nconst ssrInjectCssVars = (node, context) => {\n    if (!context.ssrCssVars) {\n        return;\n    }\n    // _cssVars is initialized once per render function\n    // the code is injected in ssrCodegenTransform when creating the\n    // ssr transform context\n    if (node.type === 0 /* NodeTypes.ROOT */) {\n        context.identifiers._cssVars = 1;\n    }\n    const parent = context.parent;\n    if (!parent || parent.type !== 0 /* NodeTypes.ROOT */) {\n        return;\n    }\n    if (node.type === 10 /* NodeTypes.IF_BRANCH */) {\n        for (const child of node.children) {\n            injectCssVars(child);\n        }\n    }\n    else {\n        injectCssVars(node);\n    }\n};\nfunction injectCssVars(node) {\n    if (node.type === 1 /* NodeTypes.ELEMENT */ &&\n        (node.tagType === 0 /* ElementTypes.ELEMENT */ ||\n            node.tagType === 1 /* ElementTypes.COMPONENT */) &&\n        !compilerDom.findDir(node, 'for')) {\n        if (compilerDom.isBuiltInType(node.tag, 'Suspense')) {\n            for (const child of node.children) {\n                if (child.type === 1 /* NodeTypes.ELEMENT */ &&\n                    child.tagType === 3 /* ElementTypes.TEMPLATE */) {\n                    // suspense slot\n                    child.children.forEach(injectCssVars);\n                }\n                else {\n                    injectCssVars(child);\n                }\n            }\n        }\n        else {\n            node.props.push({\n                type: 7 /* NodeTypes.DIRECTIVE */,\n                name: 'bind',\n                arg: undefined,\n                exp: compilerDom.createSimpleExpression(`_cssVars`, false),\n                modifiers: [],\n                loc: compilerDom.locStub\n            });\n        }\n    }\n}\n\nfunction compile(template, options = {}) {\n    options = {\n        ...options,\n        // apply DOM-specific parsing options\n        ...compilerDom.parserOptions,\n        ssr: true,\n        inSSR: true,\n        scopeId: options.mode === 'function' ? null : options.scopeId,\n        // always prefix since compiler-ssr doesn't have size concern\n        prefixIdentifiers: true,\n        // disable optimizations that are unnecessary for ssr\n        cacheHandlers: false,\n        hoistStatic: false\n    };\n    const ast = compilerDom.baseParse(template, options);\n    // Save raw options for AST. This is needed when performing sub-transforms\n    // on slot vnode branches.\n    rawOptionsMap.set(ast, options);\n    compilerDom.transform(ast, {\n        ...options,\n        hoistStatic: false,\n        nodeTransforms: [\n            ssrTransformIf,\n            ssrTransformFor,\n            compilerDom.trackVForSlotScopes,\n            compilerDom.transformExpression,\n            ssrTransformSlotOutlet,\n            ssrInjectFallthroughAttrs,\n            ssrInjectCssVars,\n            ssrTransformElement,\n            ssrTransformComponent,\n            compilerDom.trackSlotScopes,\n            compilerDom.transformStyle,\n            ...(options.nodeTransforms || []) // user transforms\n        ],\n        directiveTransforms: {\n            // reusing core v-bind\n            bind: compilerDom.transformBind,\n            on: compilerDom.transformOn,\n            // model and show has dedicated SSR handling\n            model: ssrTransformModel,\n            show: ssrTransformShow,\n            // the following are ignored during SSR\n            // on: noopDirectiveTransform,\n            cloak: compilerDom.noopDirectiveTransform,\n            once: compilerDom.noopDirectiveTransform,\n            memo: compilerDom.noopDirectiveTransform,\n            ...(options.directiveTransforms || {}) // user transforms\n        }\n    });\n    // traverse the template AST and convert into SSR codegen AST\n    // by replacing ast.codegenNode.\n    ssrCodegenTransform(ast, options);\n    return compilerDom.generate(ast, options);\n}\n\nexports.compile = compile;\n"]}