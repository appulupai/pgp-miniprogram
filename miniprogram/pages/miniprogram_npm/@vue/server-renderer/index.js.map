{"version":3,"sources":["index.js","dist/server-renderer.cjs.prod.js","dist/server-renderer.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/server-renderer.cjs.prod.js')\n} else {\n  module.exports = require('./dist/server-renderer.cjs.js')\n}\n","\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar vue = require('vue');\nvar shared = require('@vue/shared');\nvar compilerSsr = require('@vue/compiler-ssr');\n\n// leading comma for empty string \"\"\nconst shouldIgnoreProp = shared.makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);\nfunction ssrRenderAttrs(props, tag) {\n    let ret = '';\n    for (const key in props) {\n        if (shouldIgnoreProp(key) ||\n            shared.isOn(key) ||\n            (tag === 'textarea' && key === 'value')) {\n            continue;\n        }\n        const value = props[key];\n        if (key === 'class') {\n            ret += ` class=\"${ssrRenderClass(value)}\"`;\n        }\n        else if (key === 'style') {\n            ret += ` style=\"${ssrRenderStyle(value)}\"`;\n        }\n        else {\n            ret += ssrRenderDynamicAttr(key, value, tag);\n        }\n    }\n    return ret;\n}\n// render an attr with dynamic (unknown) key.\nfunction ssrRenderDynamicAttr(key, value, tag) {\n    if (!isRenderableValue(value)) {\n        return ``;\n    }\n    const attrKey = tag && (tag.indexOf('-') > 0 || shared.isSVGTag(tag))\n        ? key // preserve raw name on custom elements and svg\n        : shared.propsToAttrMap[key] || key.toLowerCase();\n    if (shared.isBooleanAttr(attrKey)) {\n        return shared.includeBooleanAttr(value) ? ` ${attrKey}` : ``;\n    }\n    else if (shared.isSSRSafeAttrName(attrKey)) {\n        return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${shared.escapeHtml(value)}\"`;\n    }\n    else {\n        console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);\n        return ``;\n    }\n}\n// Render a v-bind attr with static key. The key is pre-processed at compile\n// time and we only need to check and escape value.\nfunction ssrRenderAttr(key, value) {\n    if (!isRenderableValue(value)) {\n        return ``;\n    }\n    return ` ${key}=\"${shared.escapeHtml(value)}\"`;\n}\nfunction isRenderableValue(value) {\n    if (value == null) {\n        return false;\n    }\n    const type = typeof value;\n    return type === 'string' || type === 'number' || type === 'boolean';\n}\nfunction ssrRenderClass(raw) {\n    return shared.escapeHtml(shared.normalizeClass(raw));\n}\nfunction ssrRenderStyle(raw) {\n    if (!raw) {\n        return '';\n    }\n    if (shared.isString(raw)) {\n        return shared.escapeHtml(raw);\n    }\n    const styles = shared.normalizeStyle(raw);\n    return shared.escapeHtml(shared.stringifyStyle(styles));\n}\n\nconst compileCache = Object.create(null);\nfunction ssrCompile(template, instance) {\n    // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\n    const Component = instance.type;\n    const { isCustomElement, compilerOptions } = instance.appContext.config;\n    const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n    const finalCompilerOptions = shared.extend(shared.extend({\n        isCustomElement,\n        delimiters\n    }, compilerOptions), componentCompilerOptions);\n    finalCompilerOptions.isCustomElement =\n        finalCompilerOptions.isCustomElement || shared.NO;\n    finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || shared.NO;\n    const cacheKey = JSON.stringify({\n        template,\n        compilerOptions: finalCompilerOptions\n    }, (key, value) => {\n        return shared.isFunction(value) ? value.toString() : value;\n    });\n    const cached = compileCache[cacheKey];\n    if (cached) {\n        return cached;\n    }\n    finalCompilerOptions.onError = (err) => {\n        {\n            throw err;\n        }\n    };\n    const { code } = compilerSsr.compile(template, finalCompilerOptions);\n    return (compileCache[cacheKey] = Function('require', code)(require));\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\n    parentPush('<!--teleport start-->');\n    const context = parentComponent.appContext.provides[vue.ssrContextKey];\n    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\n    const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);\n    // record current index of the target buffer to handle nested teleports\n    // since the parent needs to be rendered before the child\n    const bufferIndex = targetBuffer.length;\n    let teleportContent;\n    if (disabled) {\n        contentRenderFn(parentPush);\n        teleportContent = `<!--teleport anchor-->`;\n    }\n    else {\n        const { getBuffer, push } = createBuffer();\n        contentRenderFn(push);\n        push(`<!--teleport anchor-->`);\n        teleportContent = getBuffer();\n    }\n    targetBuffer.splice(bufferIndex, 0, teleportContent);\n    parentPush('<!--teleport end-->');\n}\n\nconst { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = vue.ssrUtils;\n// Each component has a buffer array.\n// A buffer array can contain one of the following:\n// - plain string\n// - A resolved buffer (recursive arrays of strings that can be unrolled\n//   synchronously)\n// - An async buffer (a Promise that resolves to a resolved buffer)\nfunction createBuffer() {\n    let appendable = false;\n    const buffer = [];\n    return {\n        getBuffer() {\n            // Return static buffer and await on items during unroll stage\n            return buffer;\n        },\n        push(item) {\n            const isStringItem = shared.isString(item);\n            if (appendable && isStringItem) {\n                buffer[buffer.length - 1] += item;\n            }\n            else {\n                buffer.push(item);\n            }\n            appendable = isStringItem;\n            if (shared.isPromise(item) || (shared.isArray(item) && item.hasAsync)) {\n                // promise, or child buffer with async, mark as async.\n                // this allows skipping unnecessary await ticks during unroll stage\n                buffer.hasAsync = true;\n            }\n        }\n    };\n}\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\n    const instance = createComponentInstance(vnode, parentComponent, null);\n    const res = setupComponent(instance, true /* isSSR */);\n    const hasAsyncSetup = shared.isPromise(res);\n    const prefetches = instance.sp; /* LifecycleHooks.SERVER_PREFETCH */\n    if (hasAsyncSetup || prefetches) {\n        let p = hasAsyncSetup\n            ? res\n            : Promise.resolve();\n        if (prefetches) {\n            p = p\n                .then(() => Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy))))\n                // Note: error display is already done by the wrapped lifecycle hook function.\n                .catch(() => { });\n        }\n        return p.then(() => renderComponentSubTree(instance, slotScopeId));\n    }\n    else {\n        return renderComponentSubTree(instance, slotScopeId);\n    }\n}\nfunction renderComponentSubTree(instance, slotScopeId) {\n    const comp = instance.type;\n    const { getBuffer, push } = createBuffer();\n    if (shared.isFunction(comp)) {\n        let root = renderComponentRoot(instance);\n        // #5817 scope ID attrs not falling through if functional component doesn't\n        // have props\n        if (!comp.props) {\n            for (const key in instance.attrs) {\n                if (key.startsWith(`data-v-`)) {\n                    (root.props || (root.props = {}))[key] = ``;\n                }\n            }\n        }\n        renderVNode(push, (instance.subTree = root), instance, slotScopeId);\n    }\n    else {\n        if ((!instance.render || instance.render === shared.NOOP) &&\n            !instance.ssrRender &&\n            !comp.ssrRender &&\n            shared.isString(comp.template)) {\n            comp.ssrRender = ssrCompile(comp.template, instance);\n        }\n        // perf: enable caching of computed getters during render\n        // since there cannot be state mutations during render.\n        for (const e of instance.scope.effects) {\n            if (e.computed)\n                e.computed._cacheable = true;\n        }\n        const ssrRender = instance.ssrRender || comp.ssrRender;\n        if (ssrRender) {\n            // optimized\n            // resolve fallthrough attrs\n            let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;\n            let hasCloned = false;\n            let cur = instance;\n            while (true) {\n                const scopeId = cur.vnode.scopeId;\n                if (scopeId) {\n                    if (!hasCloned) {\n                        attrs = { ...attrs };\n                        hasCloned = true;\n                    }\n                    attrs[scopeId] = '';\n                }\n                const parent = cur.parent;\n                if (parent && parent.subTree && parent.subTree === cur.vnode) {\n                    // parent is a non-SSR compiled component and is rendering this\n                    // component as root. inherit its scopeId if present.\n                    cur = parent;\n                }\n                else {\n                    break;\n                }\n            }\n            if (slotScopeId) {\n                if (!hasCloned)\n                    attrs = { ...attrs };\n                attrs[slotScopeId.trim()] = '';\n            }\n            // set current rendering instance for asset resolution\n            const prev = setCurrentRenderingInstance(instance);\n            try {\n                ssrRender(instance.proxy, push, instance, attrs, \n                // compiler-optimized bindings\n                instance.props, instance.setupState, instance.data, instance.ctx);\n            }\n            finally {\n                setCurrentRenderingInstance(prev);\n            }\n        }\n        else if (instance.render && instance.render !== shared.NOOP) {\n            renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\n        }\n        else {\n            const componentName = comp.name || comp.__file || `<Anonymous>`;\n            vue.warn(`Component ${componentName} is missing template or render function.`);\n            push(`<!---->`);\n        }\n    }\n    return getBuffer();\n}\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\n    const { type, shapeFlag, children } = vnode;\n    switch (type) {\n        case vue.Text:\n            push(shared.escapeHtml(children));\n            break;\n        case vue.Comment:\n            push(children ? `<!--${shared.escapeHtmlComment(children)}-->` : `<!---->`);\n            break;\n        case vue.Static:\n            push(children);\n            break;\n        case vue.Fragment:\n            if (vnode.slotScopeIds) {\n                slotScopeId =\n                    (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ');\n            }\n            push(`<!--[-->`); // open\n            renderVNodeChildren(push, children, parentComponent, slotScopeId);\n            push(`<!--]-->`); // close\n            break;\n        default:\n            if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n                renderElementVNode(push, vnode, parentComponent, slotScopeId);\n            }\n            else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n                push(renderComponentVNode(vnode, parentComponent, slotScopeId));\n            }\n            else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n                renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\n            }\n            else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\n            }\n            else {\n                vue.warn('[@vue/server-renderer] Invalid VNode type:', type, `(${typeof type})`);\n            }\n    }\n}\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\n    for (let i = 0; i < children.length; i++) {\n        renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\n    }\n}\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\n    const tag = vnode.type;\n    let { props, children, shapeFlag, scopeId, dirs } = vnode;\n    let openTag = `<${tag}`;\n    if (dirs) {\n        props = applySSRDirectives(vnode, props, dirs);\n    }\n    if (props) {\n        openTag += ssrRenderAttrs(props, tag);\n    }\n    if (scopeId) {\n        openTag += ` ${scopeId}`;\n    }\n    // inherit parent chain scope id if this is the root node\n    let curParent = parentComponent;\n    let curVnode = vnode;\n    while (curParent && curVnode === curParent.subTree) {\n        curVnode = curParent.vnode;\n        if (curVnode.scopeId) {\n            openTag += ` ${curVnode.scopeId}`;\n        }\n        curParent = curParent.parent;\n    }\n    if (slotScopeId) {\n        openTag += ` ${slotScopeId}`;\n    }\n    push(openTag + `>`);\n    if (!shared.isVoidTag(tag)) {\n        let hasChildrenOverride = false;\n        if (props) {\n            if (props.innerHTML) {\n                hasChildrenOverride = true;\n                push(props.innerHTML);\n            }\n            else if (props.textContent) {\n                hasChildrenOverride = true;\n                push(shared.escapeHtml(props.textContent));\n            }\n            else if (tag === 'textarea' && props.value) {\n                hasChildrenOverride = true;\n                push(shared.escapeHtml(props.value));\n            }\n        }\n        if (!hasChildrenOverride) {\n            if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n                push(shared.escapeHtml(children));\n            }\n            else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                renderVNodeChildren(push, children, parentComponent, slotScopeId);\n            }\n        }\n        push(`</${tag}>`);\n    }\n}\nfunction applySSRDirectives(vnode, rawProps, dirs) {\n    const toMerge = [];\n    for (let i = 0; i < dirs.length; i++) {\n        const binding = dirs[i];\n        const { dir: { getSSRProps } } = binding;\n        if (getSSRProps) {\n            const props = getSSRProps(binding, vnode);\n            if (props)\n                toMerge.push(props);\n        }\n    }\n    return vue.mergeProps(rawProps || {}, ...toMerge);\n}\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\n    const target = vnode.props && vnode.props.to;\n    const disabled = vnode.props && vnode.props.disabled;\n    if (!target) {\n        if (!disabled) {\n            vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);\n        }\n        return [];\n    }\n    if (!shared.isString(target)) {\n        vue.warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);\n        return [];\n    }\n    ssrRenderTeleport(push, push => {\n        renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);\n    }, target, disabled || disabled === '', parentComponent);\n}\n\nconst { isVNode } = vue.ssrUtils;\nasync function unrollBuffer(buffer) {\n    if (buffer.hasAsync) {\n        let ret = '';\n        for (let i = 0; i < buffer.length; i++) {\n            let item = buffer[i];\n            if (shared.isPromise(item)) {\n                item = await item;\n            }\n            if (shared.isString(item)) {\n                ret += item;\n            }\n            else {\n                ret += await unrollBuffer(item);\n            }\n        }\n        return ret;\n    }\n    else {\n        // sync buffer can be more efficiently unrolled without unnecessary await\n        // ticks\n        return unrollBufferSync(buffer);\n    }\n}\nfunction unrollBufferSync(buffer) {\n    let ret = '';\n    for (let i = 0; i < buffer.length; i++) {\n        let item = buffer[i];\n        if (shared.isString(item)) {\n            ret += item;\n        }\n        else {\n            // since this is a sync buffer, child buffers are never promises\n            ret += unrollBufferSync(item);\n        }\n    }\n    return ret;\n}\nasync function renderToString(input, context = {}) {\n    if (isVNode(input)) {\n        // raw vnode, wrap with app (for context)\n        return renderToString(vue.createApp({ render: () => input }), context);\n    }\n    // rendering an app\n    const vnode = vue.createVNode(input._component, input._props);\n    vnode.appContext = input._context;\n    // provide the ssr context to the tree\n    input.provide(vue.ssrContextKey, context);\n    const buffer = await renderComponentVNode(vnode);\n    const result = await unrollBuffer(buffer);\n    await resolveTeleports(context);\n    return result;\n}\nasync function resolveTeleports(context) {\n    if (context.__teleportBuffers) {\n        context.teleports = context.teleports || {};\n        for (const key in context.__teleportBuffers) {\n            // note: it's OK to await sequentially here because the Promises were\n            // created eagerly in parallel.\n            context.teleports[key] = await unrollBuffer(await Promise.all([context.__teleportBuffers[key]]));\n        }\n    }\n}\n\nconst { isVNode: isVNode$1 } = vue.ssrUtils;\nasync function unrollBuffer$1(buffer, stream) {\n    if (buffer.hasAsync) {\n        for (let i = 0; i < buffer.length; i++) {\n            let item = buffer[i];\n            if (shared.isPromise(item)) {\n                item = await item;\n            }\n            if (shared.isString(item)) {\n                stream.push(item);\n            }\n            else {\n                await unrollBuffer$1(item, stream);\n            }\n        }\n    }\n    else {\n        // sync buffer can be more efficiently unrolled without unnecessary await\n        // ticks\n        unrollBufferSync$1(buffer, stream);\n    }\n}\nfunction unrollBufferSync$1(buffer, stream) {\n    for (let i = 0; i < buffer.length; i++) {\n        let item = buffer[i];\n        if (shared.isString(item)) {\n            stream.push(item);\n        }\n        else {\n            // since this is a sync buffer, child buffers are never promises\n            unrollBufferSync$1(item, stream);\n        }\n    }\n}\nfunction renderToSimpleStream(input, context, stream) {\n    if (isVNode$1(input)) {\n        // raw vnode, wrap with app (for context)\n        return renderToSimpleStream(vue.createApp({ render: () => input }), context, stream);\n    }\n    // rendering an app\n    const vnode = vue.createVNode(input._component, input._props);\n    vnode.appContext = input._context;\n    // provide the ssr context to the tree\n    input.provide(vue.ssrContextKey, context);\n    Promise.resolve(renderComponentVNode(vnode))\n        .then(buffer => unrollBuffer$1(buffer, stream))\n        .then(() => resolveTeleports(context))\n        .then(() => stream.push(null))\n        .catch(error => {\n        stream.destroy(error);\n    });\n    return stream;\n}\n/**\n * @deprecated\n */\nfunction renderToStream(input, context = {}) {\n    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);\n    return renderToNodeStream(input, context);\n}\nfunction renderToNodeStream(input, context = {}) {\n    const stream = new (require('stream').Readable)({ read() { } })\n        ;\n    if (!stream) {\n        throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). ` +\n            `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\n            `instance instead.`);\n    }\n    return renderToSimpleStream(input, context, stream);\n}\nfunction pipeToNodeWritable(input, context = {}, writable) {\n    renderToSimpleStream(input, context, {\n        push(content) {\n            if (content != null) {\n                writable.write(content);\n            }\n            else {\n                writable.end();\n            }\n        },\n        destroy(err) {\n            writable.destroy(err);\n        }\n    });\n}\nfunction renderToWebStream(input, context = {}) {\n    if (typeof ReadableStream !== 'function') {\n        throw new Error(`ReadableStream constructor is not available in the global scope. ` +\n            `If the target environment does support web streams, consider using ` +\n            `pipeToWebWritable() with an existing WritableStream instance instead.`);\n    }\n    const encoder = new TextEncoder();\n    let cancelled = false;\n    return new ReadableStream({\n        start(controller) {\n            renderToSimpleStream(input, context, {\n                push(content) {\n                    if (cancelled)\n                        return;\n                    if (content != null) {\n                        controller.enqueue(encoder.encode(content));\n                    }\n                    else {\n                        controller.close();\n                    }\n                },\n                destroy(err) {\n                    controller.error(err);\n                }\n            });\n        },\n        cancel() {\n            cancelled = true;\n        }\n    });\n}\nfunction pipeToWebWritable(input, context = {}, writable) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    // #4287 CloudFlare workers do not implement `ready` property\n    let hasReady = false;\n    try {\n        hasReady = shared.isPromise(writer.ready);\n    }\n    catch (e) { }\n    renderToSimpleStream(input, context, {\n        async push(content) {\n            if (hasReady) {\n                await writer.ready;\n            }\n            if (content != null) {\n                return writer.write(encoder.encode(content));\n            }\n            else {\n                return writer.close();\n            }\n        },\n        destroy(err) {\n            // TODO better error handling?\n            console.log(err);\n            writer.close();\n        }\n    });\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\n    return renderComponentVNode(vue.createVNode(comp, props, children), parentComponent, slotScopeId);\n}\n\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\n    // template-compiled slots are always rendered as fragments\n    push(`<!--[-->`);\n    ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);\n    push(`<!--]-->`);\n}\nfunction ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {\n    const slotFn = slots[slotName];\n    if (slotFn) {\n        const slotBuffer = [];\n        const bufferedPush = (item) => {\n            slotBuffer.push(item);\n        };\n        const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? ' ' + slotScopeId : '');\n        if (shared.isArray(ret)) {\n            // normal slot\n            renderVNodeChildren(push, ret, parentComponent, slotScopeId);\n        }\n        else {\n            // ssr slot.\n            // check if the slot renders all comments, in which case use the fallback\n            let isEmptySlot = true;\n            if (transition) {\n                isEmptySlot = false;\n            }\n            else {\n                for (let i = 0; i < slotBuffer.length; i++) {\n                    if (!isComment(slotBuffer[i])) {\n                        isEmptySlot = false;\n                        break;\n                    }\n                }\n            }\n            if (isEmptySlot) {\n                if (fallbackRenderFn) {\n                    fallbackRenderFn();\n                }\n            }\n            else {\n                for (let i = 0; i < slotBuffer.length; i++) {\n                    push(slotBuffer[i]);\n                }\n            }\n        }\n    }\n    else if (fallbackRenderFn) {\n        fallbackRenderFn();\n    }\n}\nconst commentTestRE = /^<!--.*-->$/s;\nconst commentRE = /<!--[^]*?-->/gm;\nfunction isComment(item) {\n    if (typeof item !== 'string' || !commentTestRE.test(item))\n        return false;\n    // if item is '<!---->' or '<!--[-->' or '<!--]-->', return true directly\n    if (item.length <= 8)\n        return true;\n    return !item.replace(commentRE, '').trim();\n}\n\nfunction ssrInterpolate(value) {\n    return shared.escapeHtml(shared.toDisplayString(value));\n}\n\nfunction ssrRenderList(source, renderItem) {\n    if (shared.isArray(source) || shared.isString(source)) {\n        for (let i = 0, l = source.length; i < l; i++) {\n            renderItem(source[i], i);\n        }\n    }\n    else if (typeof source === 'number') {\n        for (let i = 0; i < source; i++) {\n            renderItem(i + 1, i);\n        }\n    }\n    else if (shared.isObject(source)) {\n        if (source[Symbol.iterator]) {\n            const arr = Array.from(source);\n            for (let i = 0, l = arr.length; i < l; i++) {\n                renderItem(arr[i], i);\n            }\n        }\n        else {\n            const keys = Object.keys(source);\n            for (let i = 0, l = keys.length; i < l; i++) {\n                const key = keys[i];\n                renderItem(source[key], key, i);\n            }\n        }\n    }\n}\n\nasync function ssrRenderSuspense(push, { default: renderContent }) {\n    if (renderContent) {\n        renderContent();\n    }\n    else {\n        push(`<!---->`);\n    }\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\n    if (typeof dir !== 'function' && dir.getSSRProps) {\n        return (dir.getSSRProps({\n            dir,\n            instance,\n            value,\n            oldValue: undefined,\n            arg,\n            modifiers\n        }, null) || {});\n    }\n    return {};\n}\n\nconst ssrLooseEqual = shared.looseEqual;\nfunction ssrLooseContain(arr, value) {\n    return shared.looseIndexOf(arr, value) > -1;\n}\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\nfunction ssrRenderDynamicModel(type, model, value) {\n    switch (type) {\n        case 'radio':\n            return shared.looseEqual(model, value) ? ' checked' : '';\n        case 'checkbox':\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\n                ? ' checked'\n                : '';\n        default:\n            // text types\n            return ssrRenderAttr('value', model);\n    }\n}\n// for <input v-bind=\"obj\" v-model=\"model\">\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\n    const { type, value } = existingProps;\n    switch (type) {\n        case 'radio':\n            return shared.looseEqual(model, value) ? { checked: true } : null;\n        case 'checkbox':\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\n                ? { checked: true }\n                : null;\n        default:\n            // text types\n            return { value: model };\n    }\n}\n\nvue.initDirectivesForSSR();\n\nexports.ssrIncludeBooleanAttr = shared.includeBooleanAttr;\nexports.pipeToNodeWritable = pipeToNodeWritable;\nexports.pipeToWebWritable = pipeToWebWritable;\nexports.renderToNodeStream = renderToNodeStream;\nexports.renderToSimpleStream = renderToSimpleStream;\nexports.renderToStream = renderToStream;\nexports.renderToString = renderToString;\nexports.renderToWebStream = renderToWebStream;\nexports.ssrGetDirectiveProps = ssrGetDirectiveProps;\nexports.ssrGetDynamicModelProps = ssrGetDynamicModelProps;\nexports.ssrInterpolate = ssrInterpolate;\nexports.ssrLooseContain = ssrLooseContain;\nexports.ssrLooseEqual = ssrLooseEqual;\nexports.ssrRenderAttr = ssrRenderAttr;\nexports.ssrRenderAttrs = ssrRenderAttrs;\nexports.ssrRenderClass = ssrRenderClass;\nexports.ssrRenderComponent = ssrRenderComponent;\nexports.ssrRenderDynamicAttr = ssrRenderDynamicAttr;\nexports.ssrRenderDynamicModel = ssrRenderDynamicModel;\nexports.ssrRenderList = ssrRenderList;\nexports.ssrRenderSlot = ssrRenderSlot;\nexports.ssrRenderSlotInner = ssrRenderSlotInner;\nexports.ssrRenderStyle = ssrRenderStyle;\nexports.ssrRenderSuspense = ssrRenderSuspense;\nexports.ssrRenderTeleport = ssrRenderTeleport;\nexports.ssrRenderVNode = renderVNode;\n","\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar vue = require('vue');\nvar shared = require('@vue/shared');\nvar compilerSsr = require('@vue/compiler-ssr');\n\n// leading comma for empty string \"\"\nconst shouldIgnoreProp = shared.makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);\nfunction ssrRenderAttrs(props, tag) {\n    let ret = '';\n    for (const key in props) {\n        if (shouldIgnoreProp(key) ||\n            shared.isOn(key) ||\n            (tag === 'textarea' && key === 'value')) {\n            continue;\n        }\n        const value = props[key];\n        if (key === 'class') {\n            ret += ` class=\"${ssrRenderClass(value)}\"`;\n        }\n        else if (key === 'style') {\n            ret += ` style=\"${ssrRenderStyle(value)}\"`;\n        }\n        else {\n            ret += ssrRenderDynamicAttr(key, value, tag);\n        }\n    }\n    return ret;\n}\n// render an attr with dynamic (unknown) key.\nfunction ssrRenderDynamicAttr(key, value, tag) {\n    if (!isRenderableValue(value)) {\n        return ``;\n    }\n    const attrKey = tag && (tag.indexOf('-') > 0 || shared.isSVGTag(tag))\n        ? key // preserve raw name on custom elements and svg\n        : shared.propsToAttrMap[key] || key.toLowerCase();\n    if (shared.isBooleanAttr(attrKey)) {\n        return shared.includeBooleanAttr(value) ? ` ${attrKey}` : ``;\n    }\n    else if (shared.isSSRSafeAttrName(attrKey)) {\n        return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${shared.escapeHtml(value)}\"`;\n    }\n    else {\n        console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);\n        return ``;\n    }\n}\n// Render a v-bind attr with static key. The key is pre-processed at compile\n// time and we only need to check and escape value.\nfunction ssrRenderAttr(key, value) {\n    if (!isRenderableValue(value)) {\n        return ``;\n    }\n    return ` ${key}=\"${shared.escapeHtml(value)}\"`;\n}\nfunction isRenderableValue(value) {\n    if (value == null) {\n        return false;\n    }\n    const type = typeof value;\n    return type === 'string' || type === 'number' || type === 'boolean';\n}\nfunction ssrRenderClass(raw) {\n    return shared.escapeHtml(shared.normalizeClass(raw));\n}\nfunction ssrRenderStyle(raw) {\n    if (!raw) {\n        return '';\n    }\n    if (shared.isString(raw)) {\n        return shared.escapeHtml(raw);\n    }\n    const styles = shared.normalizeStyle(raw);\n    return shared.escapeHtml(shared.stringifyStyle(styles));\n}\n\nconst compileCache = Object.create(null);\nfunction ssrCompile(template, instance) {\n    // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\n    const Component = instance.type;\n    const { isCustomElement, compilerOptions } = instance.appContext.config;\n    const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n    const finalCompilerOptions = shared.extend(shared.extend({\n        isCustomElement,\n        delimiters\n    }, compilerOptions), componentCompilerOptions);\n    finalCompilerOptions.isCustomElement =\n        finalCompilerOptions.isCustomElement || shared.NO;\n    finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || shared.NO;\n    const cacheKey = JSON.stringify({\n        template,\n        compilerOptions: finalCompilerOptions\n    }, (key, value) => {\n        return shared.isFunction(value) ? value.toString() : value;\n    });\n    const cached = compileCache[cacheKey];\n    if (cached) {\n        return cached;\n    }\n    finalCompilerOptions.onError = (err) => {\n        {\n            const message = `[@vue/server-renderer] Template compilation error: ${err.message}`;\n            const codeFrame = err.loc &&\n                shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);\n            vue.warn(codeFrame ? `${message}\\n${codeFrame}` : message);\n        }\n    };\n    const { code } = compilerSsr.compile(template, finalCompilerOptions);\n    return (compileCache[cacheKey] = Function('require', code)(require));\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\n    parentPush('<!--teleport start-->');\n    const context = parentComponent.appContext.provides[vue.ssrContextKey];\n    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\n    const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);\n    // record current index of the target buffer to handle nested teleports\n    // since the parent needs to be rendered before the child\n    const bufferIndex = targetBuffer.length;\n    let teleportContent;\n    if (disabled) {\n        contentRenderFn(parentPush);\n        teleportContent = `<!--teleport anchor-->`;\n    }\n    else {\n        const { getBuffer, push } = createBuffer();\n        contentRenderFn(push);\n        push(`<!--teleport anchor-->`);\n        teleportContent = getBuffer();\n    }\n    targetBuffer.splice(bufferIndex, 0, teleportContent);\n    parentPush('<!--teleport end-->');\n}\n\nconst { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = vue.ssrUtils;\n// Each component has a buffer array.\n// A buffer array can contain one of the following:\n// - plain string\n// - A resolved buffer (recursive arrays of strings that can be unrolled\n//   synchronously)\n// - An async buffer (a Promise that resolves to a resolved buffer)\nfunction createBuffer() {\n    let appendable = false;\n    const buffer = [];\n    return {\n        getBuffer() {\n            // Return static buffer and await on items during unroll stage\n            return buffer;\n        },\n        push(item) {\n            const isStringItem = shared.isString(item);\n            if (appendable && isStringItem) {\n                buffer[buffer.length - 1] += item;\n            }\n            else {\n                buffer.push(item);\n            }\n            appendable = isStringItem;\n            if (shared.isPromise(item) || (shared.isArray(item) && item.hasAsync)) {\n                // promise, or child buffer with async, mark as async.\n                // this allows skipping unnecessary await ticks during unroll stage\n                buffer.hasAsync = true;\n            }\n        }\n    };\n}\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\n    const instance = createComponentInstance(vnode, parentComponent, null);\n    const res = setupComponent(instance, true /* isSSR */);\n    const hasAsyncSetup = shared.isPromise(res);\n    const prefetches = instance.sp; /* LifecycleHooks.SERVER_PREFETCH */\n    if (hasAsyncSetup || prefetches) {\n        let p = hasAsyncSetup\n            ? res\n            : Promise.resolve();\n        if (prefetches) {\n            p = p\n                .then(() => Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy))))\n                // Note: error display is already done by the wrapped lifecycle hook function.\n                .catch(() => { });\n        }\n        return p.then(() => renderComponentSubTree(instance, slotScopeId));\n    }\n    else {\n        return renderComponentSubTree(instance, slotScopeId);\n    }\n}\nfunction renderComponentSubTree(instance, slotScopeId) {\n    const comp = instance.type;\n    const { getBuffer, push } = createBuffer();\n    if (shared.isFunction(comp)) {\n        let root = renderComponentRoot(instance);\n        // #5817 scope ID attrs not falling through if functional component doesn't\n        // have props\n        if (!comp.props) {\n            for (const key in instance.attrs) {\n                if (key.startsWith(`data-v-`)) {\n                    (root.props || (root.props = {}))[key] = ``;\n                }\n            }\n        }\n        renderVNode(push, (instance.subTree = root), instance, slotScopeId);\n    }\n    else {\n        if ((!instance.render || instance.render === shared.NOOP) &&\n            !instance.ssrRender &&\n            !comp.ssrRender &&\n            shared.isString(comp.template)) {\n            comp.ssrRender = ssrCompile(comp.template, instance);\n        }\n        // perf: enable caching of computed getters during render\n        // since there cannot be state mutations during render.\n        for (const e of instance.scope.effects) {\n            if (e.computed)\n                e.computed._cacheable = true;\n        }\n        const ssrRender = instance.ssrRender || comp.ssrRender;\n        if (ssrRender) {\n            // optimized\n            // resolve fallthrough attrs\n            let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;\n            let hasCloned = false;\n            let cur = instance;\n            while (true) {\n                const scopeId = cur.vnode.scopeId;\n                if (scopeId) {\n                    if (!hasCloned) {\n                        attrs = { ...attrs };\n                        hasCloned = true;\n                    }\n                    attrs[scopeId] = '';\n                }\n                const parent = cur.parent;\n                if (parent && parent.subTree && parent.subTree === cur.vnode) {\n                    // parent is a non-SSR compiled component and is rendering this\n                    // component as root. inherit its scopeId if present.\n                    cur = parent;\n                }\n                else {\n                    break;\n                }\n            }\n            if (slotScopeId) {\n                if (!hasCloned)\n                    attrs = { ...attrs };\n                attrs[slotScopeId.trim()] = '';\n            }\n            // set current rendering instance for asset resolution\n            const prev = setCurrentRenderingInstance(instance);\n            try {\n                ssrRender(instance.proxy, push, instance, attrs, \n                // compiler-optimized bindings\n                instance.props, instance.setupState, instance.data, instance.ctx);\n            }\n            finally {\n                setCurrentRenderingInstance(prev);\n            }\n        }\n        else if (instance.render && instance.render !== shared.NOOP) {\n            renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\n        }\n        else {\n            const componentName = comp.name || comp.__file || `<Anonymous>`;\n            vue.warn(`Component ${componentName} is missing template or render function.`);\n            push(`<!---->`);\n        }\n    }\n    return getBuffer();\n}\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\n    const { type, shapeFlag, children } = vnode;\n    switch (type) {\n        case vue.Text:\n            push(shared.escapeHtml(children));\n            break;\n        case vue.Comment:\n            push(children ? `<!--${shared.escapeHtmlComment(children)}-->` : `<!---->`);\n            break;\n        case vue.Static:\n            push(children);\n            break;\n        case vue.Fragment:\n            if (vnode.slotScopeIds) {\n                slotScopeId =\n                    (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ');\n            }\n            push(`<!--[-->`); // open\n            renderVNodeChildren(push, children, parentComponent, slotScopeId);\n            push(`<!--]-->`); // close\n            break;\n        default:\n            if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n                renderElementVNode(push, vnode, parentComponent, slotScopeId);\n            }\n            else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n                push(renderComponentVNode(vnode, parentComponent, slotScopeId));\n            }\n            else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n                renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\n            }\n            else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\n            }\n            else {\n                vue.warn('[@vue/server-renderer] Invalid VNode type:', type, `(${typeof type})`);\n            }\n    }\n}\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\n    for (let i = 0; i < children.length; i++) {\n        renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\n    }\n}\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\n    const tag = vnode.type;\n    let { props, children, shapeFlag, scopeId, dirs } = vnode;\n    let openTag = `<${tag}`;\n    if (dirs) {\n        props = applySSRDirectives(vnode, props, dirs);\n    }\n    if (props) {\n        openTag += ssrRenderAttrs(props, tag);\n    }\n    if (scopeId) {\n        openTag += ` ${scopeId}`;\n    }\n    // inherit parent chain scope id if this is the root node\n    let curParent = parentComponent;\n    let curVnode = vnode;\n    while (curParent && curVnode === curParent.subTree) {\n        curVnode = curParent.vnode;\n        if (curVnode.scopeId) {\n            openTag += ` ${curVnode.scopeId}`;\n        }\n        curParent = curParent.parent;\n    }\n    if (slotScopeId) {\n        openTag += ` ${slotScopeId}`;\n    }\n    push(openTag + `>`);\n    if (!shared.isVoidTag(tag)) {\n        let hasChildrenOverride = false;\n        if (props) {\n            if (props.innerHTML) {\n                hasChildrenOverride = true;\n                push(props.innerHTML);\n            }\n            else if (props.textContent) {\n                hasChildrenOverride = true;\n                push(shared.escapeHtml(props.textContent));\n            }\n            else if (tag === 'textarea' && props.value) {\n                hasChildrenOverride = true;\n                push(shared.escapeHtml(props.value));\n            }\n        }\n        if (!hasChildrenOverride) {\n            if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n                push(shared.escapeHtml(children));\n            }\n            else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                renderVNodeChildren(push, children, parentComponent, slotScopeId);\n            }\n        }\n        push(`</${tag}>`);\n    }\n}\nfunction applySSRDirectives(vnode, rawProps, dirs) {\n    const toMerge = [];\n    for (let i = 0; i < dirs.length; i++) {\n        const binding = dirs[i];\n        const { dir: { getSSRProps } } = binding;\n        if (getSSRProps) {\n            const props = getSSRProps(binding, vnode);\n            if (props)\n                toMerge.push(props);\n        }\n    }\n    return vue.mergeProps(rawProps || {}, ...toMerge);\n}\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\n    const target = vnode.props && vnode.props.to;\n    const disabled = vnode.props && vnode.props.disabled;\n    if (!target) {\n        if (!disabled) {\n            vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);\n        }\n        return [];\n    }\n    if (!shared.isString(target)) {\n        vue.warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);\n        return [];\n    }\n    ssrRenderTeleport(push, push => {\n        renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);\n    }, target, disabled || disabled === '', parentComponent);\n}\n\nconst { isVNode } = vue.ssrUtils;\nasync function unrollBuffer(buffer) {\n    if (buffer.hasAsync) {\n        let ret = '';\n        for (let i = 0; i < buffer.length; i++) {\n            let item = buffer[i];\n            if (shared.isPromise(item)) {\n                item = await item;\n            }\n            if (shared.isString(item)) {\n                ret += item;\n            }\n            else {\n                ret += await unrollBuffer(item);\n            }\n        }\n        return ret;\n    }\n    else {\n        // sync buffer can be more efficiently unrolled without unnecessary await\n        // ticks\n        return unrollBufferSync(buffer);\n    }\n}\nfunction unrollBufferSync(buffer) {\n    let ret = '';\n    for (let i = 0; i < buffer.length; i++) {\n        let item = buffer[i];\n        if (shared.isString(item)) {\n            ret += item;\n        }\n        else {\n            // since this is a sync buffer, child buffers are never promises\n            ret += unrollBufferSync(item);\n        }\n    }\n    return ret;\n}\nasync function renderToString(input, context = {}) {\n    if (isVNode(input)) {\n        // raw vnode, wrap with app (for context)\n        return renderToString(vue.createApp({ render: () => input }), context);\n    }\n    // rendering an app\n    const vnode = vue.createVNode(input._component, input._props);\n    vnode.appContext = input._context;\n    // provide the ssr context to the tree\n    input.provide(vue.ssrContextKey, context);\n    const buffer = await renderComponentVNode(vnode);\n    const result = await unrollBuffer(buffer);\n    await resolveTeleports(context);\n    return result;\n}\nasync function resolveTeleports(context) {\n    if (context.__teleportBuffers) {\n        context.teleports = context.teleports || {};\n        for (const key in context.__teleportBuffers) {\n            // note: it's OK to await sequentially here because the Promises were\n            // created eagerly in parallel.\n            context.teleports[key] = await unrollBuffer(await Promise.all([context.__teleportBuffers[key]]));\n        }\n    }\n}\n\nconst { isVNode: isVNode$1 } = vue.ssrUtils;\nasync function unrollBuffer$1(buffer, stream) {\n    if (buffer.hasAsync) {\n        for (let i = 0; i < buffer.length; i++) {\n            let item = buffer[i];\n            if (shared.isPromise(item)) {\n                item = await item;\n            }\n            if (shared.isString(item)) {\n                stream.push(item);\n            }\n            else {\n                await unrollBuffer$1(item, stream);\n            }\n        }\n    }\n    else {\n        // sync buffer can be more efficiently unrolled without unnecessary await\n        // ticks\n        unrollBufferSync$1(buffer, stream);\n    }\n}\nfunction unrollBufferSync$1(buffer, stream) {\n    for (let i = 0; i < buffer.length; i++) {\n        let item = buffer[i];\n        if (shared.isString(item)) {\n            stream.push(item);\n        }\n        else {\n            // since this is a sync buffer, child buffers are never promises\n            unrollBufferSync$1(item, stream);\n        }\n    }\n}\nfunction renderToSimpleStream(input, context, stream) {\n    if (isVNode$1(input)) {\n        // raw vnode, wrap with app (for context)\n        return renderToSimpleStream(vue.createApp({ render: () => input }), context, stream);\n    }\n    // rendering an app\n    const vnode = vue.createVNode(input._component, input._props);\n    vnode.appContext = input._context;\n    // provide the ssr context to the tree\n    input.provide(vue.ssrContextKey, context);\n    Promise.resolve(renderComponentVNode(vnode))\n        .then(buffer => unrollBuffer$1(buffer, stream))\n        .then(() => resolveTeleports(context))\n        .then(() => stream.push(null))\n        .catch(error => {\n        stream.destroy(error);\n    });\n    return stream;\n}\n/**\n * @deprecated\n */\nfunction renderToStream(input, context = {}) {\n    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);\n    return renderToNodeStream(input, context);\n}\nfunction renderToNodeStream(input, context = {}) {\n    const stream = new (require('stream').Readable)({ read() { } })\n        ;\n    if (!stream) {\n        throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). ` +\n            `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\n            `instance instead.`);\n    }\n    return renderToSimpleStream(input, context, stream);\n}\nfunction pipeToNodeWritable(input, context = {}, writable) {\n    renderToSimpleStream(input, context, {\n        push(content) {\n            if (content != null) {\n                writable.write(content);\n            }\n            else {\n                writable.end();\n            }\n        },\n        destroy(err) {\n            writable.destroy(err);\n        }\n    });\n}\nfunction renderToWebStream(input, context = {}) {\n    if (typeof ReadableStream !== 'function') {\n        throw new Error(`ReadableStream constructor is not available in the global scope. ` +\n            `If the target environment does support web streams, consider using ` +\n            `pipeToWebWritable() with an existing WritableStream instance instead.`);\n    }\n    const encoder = new TextEncoder();\n    let cancelled = false;\n    return new ReadableStream({\n        start(controller) {\n            renderToSimpleStream(input, context, {\n                push(content) {\n                    if (cancelled)\n                        return;\n                    if (content != null) {\n                        controller.enqueue(encoder.encode(content));\n                    }\n                    else {\n                        controller.close();\n                    }\n                },\n                destroy(err) {\n                    controller.error(err);\n                }\n            });\n        },\n        cancel() {\n            cancelled = true;\n        }\n    });\n}\nfunction pipeToWebWritable(input, context = {}, writable) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    // #4287 CloudFlare workers do not implement `ready` property\n    let hasReady = false;\n    try {\n        hasReady = shared.isPromise(writer.ready);\n    }\n    catch (e) { }\n    renderToSimpleStream(input, context, {\n        async push(content) {\n            if (hasReady) {\n                await writer.ready;\n            }\n            if (content != null) {\n                return writer.write(encoder.encode(content));\n            }\n            else {\n                return writer.close();\n            }\n        },\n        destroy(err) {\n            // TODO better error handling?\n            console.log(err);\n            writer.close();\n        }\n    });\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\n    return renderComponentVNode(vue.createVNode(comp, props, children), parentComponent, slotScopeId);\n}\n\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\n    // template-compiled slots are always rendered as fragments\n    push(`<!--[-->`);\n    ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);\n    push(`<!--]-->`);\n}\nfunction ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {\n    const slotFn = slots[slotName];\n    if (slotFn) {\n        const slotBuffer = [];\n        const bufferedPush = (item) => {\n            slotBuffer.push(item);\n        };\n        const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? ' ' + slotScopeId : '');\n        if (shared.isArray(ret)) {\n            // normal slot\n            renderVNodeChildren(push, ret, parentComponent, slotScopeId);\n        }\n        else {\n            // ssr slot.\n            // check if the slot renders all comments, in which case use the fallback\n            let isEmptySlot = true;\n            if (transition) {\n                isEmptySlot = false;\n            }\n            else {\n                for (let i = 0; i < slotBuffer.length; i++) {\n                    if (!isComment(slotBuffer[i])) {\n                        isEmptySlot = false;\n                        break;\n                    }\n                }\n            }\n            if (isEmptySlot) {\n                if (fallbackRenderFn) {\n                    fallbackRenderFn();\n                }\n            }\n            else {\n                for (let i = 0; i < slotBuffer.length; i++) {\n                    push(slotBuffer[i]);\n                }\n            }\n        }\n    }\n    else if (fallbackRenderFn) {\n        fallbackRenderFn();\n    }\n}\nconst commentTestRE = /^<!--.*-->$/s;\nconst commentRE = /<!--[^]*?-->/gm;\nfunction isComment(item) {\n    if (typeof item !== 'string' || !commentTestRE.test(item))\n        return false;\n    // if item is '<!---->' or '<!--[-->' or '<!--]-->', return true directly\n    if (item.length <= 8)\n        return true;\n    return !item.replace(commentRE, '').trim();\n}\n\nfunction ssrInterpolate(value) {\n    return shared.escapeHtml(shared.toDisplayString(value));\n}\n\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\n\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n    stack.push(vnode);\n}\nfunction popWarningContext() {\n    stack.pop();\n}\nfunction warn(msg, ...args) {\n    const instance = stack.length ? stack[stack.length - 1].component : null;\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\n    const trace = getComponentTrace();\n    if (appWarnHandler) {\n        callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [\n            msg + args.join(''),\n            instance && instance.proxy,\n            trace\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\n                .join('\\n'),\n            trace\n        ]);\n    }\n    else {\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n        /* istanbul ignore if */\n        if (trace.length &&\n            // avoid spamming console during tests\n            !false) {\n            warnArgs.push(`\\n`, ...formatTrace(trace));\n        }\n        console.warn(...warnArgs);\n    }\n}\nfunction getComponentTrace() {\n    let currentVNode = stack[stack.length - 1];\n    if (!currentVNode) {\n        return [];\n    }\n    // we can't just use the stack because it will be incomplete during updates\n    // that did not start from the root. Re-construct the parent chain using\n    // instance parent pointers.\n    const normalizedStack = [];\n    while (currentVNode) {\n        const last = normalizedStack[0];\n        if (last && last.vnode === currentVNode) {\n            last.recurseCount++;\n        }\n        else {\n            normalizedStack.push({\n                vnode: currentVNode,\n                recurseCount: 0\n            });\n        }\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\n        currentVNode = parentInstance && parentInstance.vnode;\n    }\n    return normalizedStack;\n}\n/* istanbul ignore next */\nfunction formatTrace(trace) {\n    const logs = [];\n    trace.forEach((entry, i) => {\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n    });\n    return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n    const close = `>` + postfix;\n    return vnode.props\n        ? [open, ...formatProps(vnode.props), close]\n        : [open + close];\n}\n/* istanbul ignore next */\nfunction formatProps(props) {\n    const res = [];\n    const keys = Object.keys(props);\n    keys.slice(0, 3).forEach(key => {\n        res.push(...formatProp(key, props[key]));\n    });\n    if (keys.length > 3) {\n        res.push(` ...`);\n    }\n    return res;\n}\n/* istanbul ignore next */\nfunction formatProp(key, value, raw) {\n    if (shared.isString(value)) {\n        value = JSON.stringify(value);\n        return raw ? value : [`${key}=${value}`];\n    }\n    else if (typeof value === 'number' ||\n        typeof value === 'boolean' ||\n        value == null) {\n        return raw ? value : [`${key}=${value}`];\n    }\n    else if (isRef(value)) {\n        value = formatProp(key, toRaw(value.value), true);\n        return raw ? value : [`${key}=Ref<`, value, `>`];\n    }\n    else if (shared.isFunction(value)) {\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n    }\n    else {\n        value = toRaw(value);\n        return raw ? value : [`${key}=`, value];\n    }\n}\n\nconst ErrorTypeStrings = {\n    [\"sp\" /* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',\n    [\"bc\" /* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',\n    [\"c\" /* LifecycleHooks.CREATED */]: 'created hook',\n    [\"bm\" /* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',\n    [\"m\" /* LifecycleHooks.MOUNTED */]: 'mounted hook',\n    [\"bu\" /* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',\n    [\"u\" /* LifecycleHooks.UPDATED */]: 'updated',\n    [\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',\n    [\"um\" /* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',\n    [\"a\" /* LifecycleHooks.ACTIVATED */]: 'activated hook',\n    [\"da\" /* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',\n    [\"ec\" /* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',\n    [\"rtc\" /* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',\n    [\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',\n    [0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',\n    [1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',\n    [2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',\n    [3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',\n    [4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',\n    [5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',\n    [6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',\n    [7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',\n    [8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',\n    [9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',\n    [10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',\n    [11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',\n    [12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',\n    [13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',\n    [14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n    let res;\n    try {\n        res = args ? fn(...args) : fn();\n    }\n    catch (err) {\n        handleError(err, instance, type);\n    }\n    return res;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n    const contextVNode = instance ? instance.vnode : null;\n    if (instance) {\n        let cur = instance.parent;\n        // the exposed instance is the render proxy to keep it consistent with 2.x\n        const exposedInstance = instance.proxy;\n        // in production the hook receives only the error code\n        const errorInfo = ErrorTypeStrings[type] ;\n        while (cur) {\n            const errorCapturedHooks = cur.ec;\n            if (errorCapturedHooks) {\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n                        return;\n                    }\n                }\n            }\n            cur = cur.parent;\n        }\n        // app-level handling\n        const appErrorHandler = instance.appContext.config.errorHandler;\n        if (appErrorHandler) {\n            callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\n            return;\n        }\n    }\n    logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n    {\n        const info = ErrorTypeStrings[type];\n        if (contextVNode) {\n            pushWarningContext(contextVNode);\n        }\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n        if (contextVNode) {\n            popWarningContext();\n        }\n        // crash in dev by default so it's more noticeable\n        if (throwInDev) {\n            throw err;\n        }\n        else {\n            console.error(err);\n        }\n    }\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\nfunction getComponentName(Component, includeInferred = true) {\n    return shared.isFunction(Component)\n        ? Component.displayName || Component.name\n        : Component.name || (includeInferred && Component.__name);\n}\n/* istanbul ignore next */\nfunction formatComponentName(instance, Component, isRoot = false) {\n    let name = getComponentName(Component);\n    if (!name && Component.__file) {\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n        if (match) {\n            name = match[1];\n        }\n    }\n    if (!name && instance && instance.parent) {\n        // try to infer the name based on reverse resolution\n        const inferFromRegistry = (registry) => {\n            for (const key in registry) {\n                if (registry[key] === Component) {\n                    return key;\n                }\n            }\n        };\n        name =\n            inferFromRegistry(instance.components ||\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n    }\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\n\nfunction ssrRenderList(source, renderItem) {\n    if (shared.isArray(source) || shared.isString(source)) {\n        for (let i = 0, l = source.length; i < l; i++) {\n            renderItem(source[i], i);\n        }\n    }\n    else if (typeof source === 'number') {\n        if (!Number.isInteger(source)) {\n            warn(`The v-for range expect an integer value but got ${source}.`);\n            return;\n        }\n        for (let i = 0; i < source; i++) {\n            renderItem(i + 1, i);\n        }\n    }\n    else if (shared.isObject(source)) {\n        if (source[Symbol.iterator]) {\n            const arr = Array.from(source);\n            for (let i = 0, l = arr.length; i < l; i++) {\n                renderItem(arr[i], i);\n            }\n        }\n        else {\n            const keys = Object.keys(source);\n            for (let i = 0, l = keys.length; i < l; i++) {\n                const key = keys[i];\n                renderItem(source[key], key, i);\n            }\n        }\n    }\n}\n\nasync function ssrRenderSuspense(push, { default: renderContent }) {\n    if (renderContent) {\n        renderContent();\n    }\n    else {\n        push(`<!---->`);\n    }\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\n    if (typeof dir !== 'function' && dir.getSSRProps) {\n        return (dir.getSSRProps({\n            dir,\n            instance,\n            value,\n            oldValue: undefined,\n            arg,\n            modifiers\n        }, null) || {});\n    }\n    return {};\n}\n\nconst ssrLooseEqual = shared.looseEqual;\nfunction ssrLooseContain(arr, value) {\n    return shared.looseIndexOf(arr, value) > -1;\n}\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\nfunction ssrRenderDynamicModel(type, model, value) {\n    switch (type) {\n        case 'radio':\n            return shared.looseEqual(model, value) ? ' checked' : '';\n        case 'checkbox':\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\n                ? ' checked'\n                : '';\n        default:\n            // text types\n            return ssrRenderAttr('value', model);\n    }\n}\n// for <input v-bind=\"obj\" v-model=\"model\">\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\n    const { type, value } = existingProps;\n    switch (type) {\n        case 'radio':\n            return shared.looseEqual(model, value) ? { checked: true } : null;\n        case 'checkbox':\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\n                ? { checked: true }\n                : null;\n        default:\n            // text types\n            return { value: model };\n    }\n}\n\nvue.initDirectivesForSSR();\n\nexports.ssrIncludeBooleanAttr = shared.includeBooleanAttr;\nexports.pipeToNodeWritable = pipeToNodeWritable;\nexports.pipeToWebWritable = pipeToWebWritable;\nexports.renderToNodeStream = renderToNodeStream;\nexports.renderToSimpleStream = renderToSimpleStream;\nexports.renderToStream = renderToStream;\nexports.renderToString = renderToString;\nexports.renderToWebStream = renderToWebStream;\nexports.ssrGetDirectiveProps = ssrGetDirectiveProps;\nexports.ssrGetDynamicModelProps = ssrGetDynamicModelProps;\nexports.ssrInterpolate = ssrInterpolate;\nexports.ssrLooseContain = ssrLooseContain;\nexports.ssrLooseEqual = ssrLooseEqual;\nexports.ssrRenderAttr = ssrRenderAttr;\nexports.ssrRenderAttrs = ssrRenderAttrs;\nexports.ssrRenderClass = ssrRenderClass;\nexports.ssrRenderComponent = ssrRenderComponent;\nexports.ssrRenderDynamicAttr = ssrRenderDynamicAttr;\nexports.ssrRenderDynamicModel = ssrRenderDynamicModel;\nexports.ssrRenderList = ssrRenderList;\nexports.ssrRenderSlot = ssrRenderSlot;\nexports.ssrRenderSlotInner = ssrRenderSlotInner;\nexports.ssrRenderStyle = ssrRenderStyle;\nexports.ssrRenderSuspense = ssrRenderSuspense;\nexports.ssrRenderTeleport = ssrRenderTeleport;\nexports.ssrRenderVNode = renderVNode;\n"]}