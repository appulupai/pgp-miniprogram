{"version":3,"sources":["reactivity-transform.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar MagicString = require('magic-string');\nvar estreeWalker = require('estree-walker');\nvar compilerCore = require('@vue/compiler-core');\nvar parser = require('@babel/parser');\nvar shared = require('@vue/shared');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }\n\nvar MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);\n\nconst CONVERT_SYMBOL = '$';\nconst ESCAPE_SYMBOL = '$$';\nconst shorthands = ['ref', 'computed', 'shallowRef', 'toRef', 'customRef'];\nconst transformCheckRE = /[^\\w]\\$(?:\\$|ref|computed|shallowRef)?\\s*(\\(|\\<)/;\nfunction shouldTransform(src) {\n    return transformCheckRE.test(src);\n}\nfunction transform(src, { filename, sourceMap, parserPlugins, importHelpersFrom = 'vue' } = {}) {\n    const plugins = parserPlugins || [];\n    if (filename) {\n        if (/\\.tsx?$/.test(filename)) {\n            plugins.push('typescript');\n        }\n        if (filename.endsWith('x')) {\n            plugins.push('jsx');\n        }\n    }\n    const ast = parser.parse(src, {\n        sourceType: 'module',\n        plugins\n    });\n    const s = new MagicString__default(src);\n    const res = transformAST(ast.program, s, 0);\n    // inject helper imports\n    if (res.importedHelpers.length) {\n        s.prepend(`import { ${res.importedHelpers\n            .map(h => `${h} as _${h}`)\n            .join(', ')} } from '${importHelpersFrom}'\\n`);\n    }\n    return {\n        ...res,\n        code: s.toString(),\n        map: sourceMap\n            ? s.generateMap({\n                source: filename,\n                hires: true,\n                includeContent: true\n            })\n            : null\n    };\n}\nfunction transformAST(ast, s, offset = 0, knownRefs, knownProps) {\n    // TODO remove when out of experimental\n    warnExperimental();\n    let convertSymbol = CONVERT_SYMBOL;\n    let escapeSymbol = ESCAPE_SYMBOL;\n    // macro import handling\n    for (const node of ast.body) {\n        if (node.type === 'ImportDeclaration' &&\n            node.source.value === 'vue/macros') {\n            // remove macro imports\n            s.remove(node.start + offset, node.end + offset);\n            // check aliasing\n            for (const specifier of node.specifiers) {\n                if (specifier.type === 'ImportSpecifier') {\n                    const imported = specifier.imported.name;\n                    const local = specifier.local.name;\n                    if (local !== imported) {\n                        if (imported === ESCAPE_SYMBOL) {\n                            escapeSymbol = local;\n                        }\n                        else if (imported === CONVERT_SYMBOL) {\n                            convertSymbol = local;\n                        }\n                        else {\n                            error(`macro imports for ref-creating methods do not support aliasing.`, specifier);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    const importedHelpers = new Set();\n    const rootScope = {};\n    const scopeStack = [rootScope];\n    let currentScope = rootScope;\n    let escapeScope; // inside $$()\n    const excludedIds = new WeakSet();\n    const parentStack = [];\n    const propsLocalToPublicMap = Object.create(null);\n    if (knownRefs) {\n        for (const key of knownRefs) {\n            rootScope[key] = true;\n        }\n    }\n    if (knownProps) {\n        for (const key in knownProps) {\n            const { local } = knownProps[key];\n            rootScope[local] = 'prop';\n            propsLocalToPublicMap[local] = key;\n        }\n    }\n    function isRefCreationCall(callee) {\n        if (callee === convertSymbol) {\n            return convertSymbol;\n        }\n        if (callee[0] === '$' && shorthands.includes(callee.slice(1))) {\n            return callee;\n        }\n        return false;\n    }\n    function error(msg, node) {\n        const e = new Error(msg);\n        e.node = node;\n        throw e;\n    }\n    function helper(msg) {\n        importedHelpers.add(msg);\n        return `_${msg}`;\n    }\n    function registerBinding(id, isRef = false) {\n        excludedIds.add(id);\n        if (currentScope) {\n            currentScope[id.name] = isRef;\n        }\n        else {\n            error('registerBinding called without active scope, something is wrong.', id);\n        }\n    }\n    const registerRefBinding = (id) => registerBinding(id, true);\n    let tempVarCount = 0;\n    function genTempVar() {\n        return `__$temp_${++tempVarCount}`;\n    }\n    function snip(node) {\n        return s.original.slice(node.start + offset, node.end + offset);\n    }\n    function walkScope(node, isRoot = false) {\n        for (const stmt of node.body) {\n            if (stmt.type === 'VariableDeclaration') {\n                walkVariableDeclaration(stmt, isRoot);\n            }\n            else if (stmt.type === 'FunctionDeclaration' ||\n                stmt.type === 'ClassDeclaration') {\n                if (stmt.declare || !stmt.id)\n                    continue;\n                registerBinding(stmt.id);\n            }\n            else if ((stmt.type === 'ForOfStatement' || stmt.type === 'ForInStatement') &&\n                stmt.left.type === 'VariableDeclaration') {\n                walkVariableDeclaration(stmt.left);\n            }\n            else if (stmt.type === 'ExportNamedDeclaration' &&\n                stmt.declaration &&\n                stmt.declaration.type === 'VariableDeclaration') {\n                walkVariableDeclaration(stmt.declaration, isRoot);\n            }\n            else if (stmt.type === 'LabeledStatement' &&\n                stmt.body.type === 'VariableDeclaration') {\n                walkVariableDeclaration(stmt.body, isRoot);\n            }\n        }\n    }\n    function walkVariableDeclaration(stmt, isRoot = false) {\n        if (stmt.declare) {\n            return;\n        }\n        for (const decl of stmt.declarations) {\n            let refCall;\n            const isCall = decl.init &&\n                decl.init.type === 'CallExpression' &&\n                decl.init.callee.type === 'Identifier';\n            if (isCall &&\n                (refCall = isRefCreationCall(decl.init.callee.name))) {\n                processRefDeclaration(refCall, decl.id, decl.init);\n            }\n            else {\n                const isProps = isRoot && isCall && decl.init.callee.name === 'defineProps';\n                for (const id of compilerCore.extractIdentifiers(decl.id)) {\n                    if (isProps) {\n                        // for defineProps destructure, only exclude them since they\n                        // are already passed in as knownProps\n                        excludedIds.add(id);\n                    }\n                    else {\n                        registerBinding(id);\n                    }\n                }\n            }\n        }\n    }\n    function processRefDeclaration(method, id, call) {\n        excludedIds.add(call.callee);\n        if (method === convertSymbol) {\n            // $\n            // remove macro\n            s.remove(call.callee.start + offset, call.callee.end + offset);\n            if (id.type === 'Identifier') {\n                // single variable\n                registerRefBinding(id);\n            }\n            else if (id.type === 'ObjectPattern') {\n                processRefObjectPattern(id, call);\n            }\n            else if (id.type === 'ArrayPattern') {\n                processRefArrayPattern(id, call);\n            }\n        }\n        else {\n            // shorthands\n            if (id.type === 'Identifier') {\n                registerRefBinding(id);\n                // replace call\n                s.overwrite(call.start + offset, call.start + method.length + offset, helper(method.slice(1)));\n            }\n            else {\n                error(`${method}() cannot be used with destructure patterns.`, call);\n            }\n        }\n    }\n    function processRefObjectPattern(pattern, call, tempVar, path = []) {\n        if (!tempVar) {\n            tempVar = genTempVar();\n            // const { x } = $(useFoo()) --> const __$temp_1 = useFoo()\n            s.overwrite(pattern.start + offset, pattern.end + offset, tempVar);\n        }\n        for (const p of pattern.properties) {\n            let nameId;\n            let key;\n            let defaultValue;\n            if (p.type === 'ObjectProperty') {\n                if (p.key.start === p.value.start) {\n                    // shorthand { foo }\n                    nameId = p.key;\n                    if (p.value.type === 'Identifier') {\n                        // avoid shorthand value identifier from being processed\n                        excludedIds.add(p.value);\n                    }\n                    else if (p.value.type === 'AssignmentPattern' &&\n                        p.value.left.type === 'Identifier') {\n                        // { foo = 1 }\n                        excludedIds.add(p.value.left);\n                        defaultValue = p.value.right;\n                    }\n                }\n                else {\n                    key = p.computed ? p.key : p.key.name;\n                    if (p.value.type === 'Identifier') {\n                        // { foo: bar }\n                        nameId = p.value;\n                    }\n                    else if (p.value.type === 'ObjectPattern') {\n                        processRefObjectPattern(p.value, call, tempVar, [...path, key]);\n                    }\n                    else if (p.value.type === 'ArrayPattern') {\n                        processRefArrayPattern(p.value, call, tempVar, [...path, key]);\n                    }\n                    else if (p.value.type === 'AssignmentPattern') {\n                        if (p.value.left.type === 'Identifier') {\n                            // { foo: bar = 1 }\n                            nameId = p.value.left;\n                            defaultValue = p.value.right;\n                        }\n                        else if (p.value.left.type === 'ObjectPattern') {\n                            processRefObjectPattern(p.value.left, call, tempVar, [\n                                ...path,\n                                [key, p.value.right]\n                            ]);\n                        }\n                        else if (p.value.left.type === 'ArrayPattern') {\n                            processRefArrayPattern(p.value.left, call, tempVar, [\n                                ...path,\n                                [key, p.value.right]\n                            ]);\n                        }\n                        else ;\n                    }\n                }\n            }\n            else {\n                // rest element { ...foo }\n                error(`reactivity destructure does not support rest elements.`, p);\n            }\n            if (nameId) {\n                registerRefBinding(nameId);\n                // inject toRef() after original replaced pattern\n                const source = pathToString(tempVar, path);\n                const keyStr = shared.isString(key)\n                    ? `'${key}'`\n                    : key\n                        ? snip(key)\n                        : `'${nameId.name}'`;\n                const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``;\n                s.appendLeft(call.end + offset, `,\\n  ${nameId.name} = ${helper('toRef')}(${source}, ${keyStr}${defaultStr})`);\n            }\n        }\n    }\n    function processRefArrayPattern(pattern, call, tempVar, path = []) {\n        if (!tempVar) {\n            // const [x] = $(useFoo()) --> const __$temp_1 = useFoo()\n            tempVar = genTempVar();\n            s.overwrite(pattern.start + offset, pattern.end + offset, tempVar);\n        }\n        for (let i = 0; i < pattern.elements.length; i++) {\n            const e = pattern.elements[i];\n            if (!e)\n                continue;\n            let nameId;\n            let defaultValue;\n            if (e.type === 'Identifier') {\n                // [a] --> [__a]\n                nameId = e;\n            }\n            else if (e.type === 'AssignmentPattern') {\n                // [a = 1]\n                nameId = e.left;\n                defaultValue = e.right;\n            }\n            else if (e.type === 'RestElement') {\n                // [...a]\n                error(`reactivity destructure does not support rest elements.`, e);\n            }\n            else if (e.type === 'ObjectPattern') {\n                processRefObjectPattern(e, call, tempVar, [...path, i]);\n            }\n            else if (e.type === 'ArrayPattern') {\n                processRefArrayPattern(e, call, tempVar, [...path, i]);\n            }\n            if (nameId) {\n                registerRefBinding(nameId);\n                // inject toRef() after original replaced pattern\n                const source = pathToString(tempVar, path);\n                const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``;\n                s.appendLeft(call.end + offset, `,\\n  ${nameId.name} = ${helper('toRef')}(${source}, ${i}${defaultStr})`);\n            }\n        }\n    }\n    function pathToString(source, path) {\n        if (path.length) {\n            for (const seg of path) {\n                if (shared.isArray(seg)) {\n                    source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`;\n                }\n                else {\n                    source += segToString(seg);\n                }\n            }\n        }\n        return source;\n    }\n    function segToString(seg) {\n        if (typeof seg === 'number') {\n            return `[${seg}]`;\n        }\n        else if (typeof seg === 'string') {\n            return `.${seg}`;\n        }\n        else {\n            return snip(seg);\n        }\n    }\n    function rewriteId(scope, id, parent, parentStack) {\n        if (shared.hasOwn(scope, id.name)) {\n            const bindingType = scope[id.name];\n            if (bindingType) {\n                const isProp = bindingType === 'prop';\n                if (compilerCore.isStaticProperty(parent) && parent.shorthand) {\n                    // let binding used in a property shorthand\n                    // skip for destructure patterns\n                    if (!parent.inPattern ||\n                        compilerCore.isInDestructureAssignment(parent, parentStack)) {\n                        if (isProp) {\n                            if (escapeScope) {\n                                // prop binding in $$()\n                                // { prop } -> { prop: __props_prop }\n                                registerEscapedPropBinding(id);\n                                s.appendLeft(id.end + offset, `: __props_${propsLocalToPublicMap[id.name]}`);\n                            }\n                            else {\n                                // { prop } -> { prop: __props.prop }\n                                s.appendLeft(id.end + offset, `: ${shared.genPropsAccessExp(propsLocalToPublicMap[id.name])}`);\n                            }\n                        }\n                        else {\n                            // { foo } -> { foo: foo.value }\n                            s.appendLeft(id.end + offset, `: ${id.name}.value`);\n                        }\n                    }\n                }\n                else {\n                    if (isProp) {\n                        if (escapeScope) {\n                            // x --> __props_x\n                            registerEscapedPropBinding(id);\n                            s.overwrite(id.start + offset, id.end + offset, `__props_${propsLocalToPublicMap[id.name]}`);\n                        }\n                        else {\n                            // x --> __props.x\n                            s.overwrite(id.start + offset, id.end + offset, shared.genPropsAccessExp(propsLocalToPublicMap[id.name]));\n                        }\n                    }\n                    else {\n                        // x --> x.value\n                        s.appendLeft(id.end + offset, '.value');\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const propBindingRefs = {};\n    function registerEscapedPropBinding(id) {\n        if (!propBindingRefs.hasOwnProperty(id.name)) {\n            propBindingRefs[id.name] = true;\n            const publicKey = propsLocalToPublicMap[id.name];\n            s.prependRight(offset, `const __props_${publicKey} = ${helper(`toRef`)}(__props, '${publicKey}')\\n`);\n        }\n    }\n    // check root scope first\n    walkScope(ast, true);\n    estreeWalker.walk(ast, {\n        enter(node, parent) {\n            parent && parentStack.push(parent);\n            // function scopes\n            if (compilerCore.isFunctionType(node)) {\n                scopeStack.push((currentScope = {}));\n                compilerCore.walkFunctionParams(node, registerBinding);\n                if (node.body.type === 'BlockStatement') {\n                    walkScope(node.body);\n                }\n                return;\n            }\n            // catch param\n            if (node.type === 'CatchClause') {\n                scopeStack.push((currentScope = {}));\n                if (node.param && node.param.type === 'Identifier') {\n                    registerBinding(node.param);\n                }\n                walkScope(node.body);\n                return;\n            }\n            // non-function block scopes\n            if (node.type === 'BlockStatement' && !compilerCore.isFunctionType(parent)) {\n                scopeStack.push((currentScope = {}));\n                walkScope(node);\n                return;\n            }\n            // skip type nodes\n            if (parent &&\n                parent.type.startsWith('TS') &&\n                parent.type !== 'TSAsExpression' &&\n                parent.type !== 'TSNonNullExpression' &&\n                parent.type !== 'TSTypeAssertion') {\n                return this.skip();\n            }\n            if (node.type === 'Identifier' &&\n                // if inside $$(), skip unless this is a destructured prop binding\n                !(escapeScope && rootScope[node.name] !== 'prop') &&\n                compilerCore.isReferencedIdentifier(node, parent, parentStack) &&\n                !excludedIds.has(node)) {\n                // walk up the scope chain to check if id should be appended .value\n                let i = scopeStack.length;\n                while (i--) {\n                    if (rewriteId(scopeStack[i], node, parent, parentStack)) {\n                        return;\n                    }\n                }\n            }\n            if (node.type === 'CallExpression' && node.callee.type === 'Identifier') {\n                const callee = node.callee.name;\n                const refCall = isRefCreationCall(callee);\n                if (refCall && (!parent || parent.type !== 'VariableDeclarator')) {\n                    return error(`${refCall} can only be used as the initializer of ` +\n                        `a variable declaration.`, node);\n                }\n                if (callee === escapeSymbol) {\n                    s.remove(node.callee.start + offset, node.callee.end + offset);\n                    escapeScope = node;\n                }\n                // TODO remove when out of experimental\n                if (callee === '$raw') {\n                    error(`$raw() has been replaced by $$(). ` +\n                        `See ${RFC_LINK} for latest updates.`, node);\n                }\n                if (callee === '$fromRef') {\n                    error(`$fromRef() has been replaced by $(). ` +\n                        `See ${RFC_LINK} for latest updates.`, node);\n                }\n            }\n        },\n        leave(node, parent) {\n            parent && parentStack.pop();\n            if ((node.type === 'BlockStatement' && !compilerCore.isFunctionType(parent)) ||\n                compilerCore.isFunctionType(node)) {\n                scopeStack.pop();\n                currentScope = scopeStack[scopeStack.length - 1] || null;\n            }\n            if (node === escapeScope) {\n                escapeScope = undefined;\n            }\n        }\n    });\n    return {\n        rootRefs: Object.keys(rootScope).filter(key => rootScope[key] === true),\n        importedHelpers: [...importedHelpers]\n    };\n}\nconst RFC_LINK = `https://github.com/vuejs/rfcs/discussions/369`;\nconst hasWarned = {};\nfunction warnExperimental() {\n    // eslint-disable-next-line\n    if (typeof window !== 'undefined') {\n        return;\n    }\n    warnOnce(`Reactivity transform is an experimental feature.\\n` +\n        `Experimental features may change behavior between patch versions.\\n` +\n        `It is recommended to pin your vue dependencies to exact versions to avoid breakage.\\n` +\n        `You can follow the proposal's status at ${RFC_LINK}.`);\n}\nfunction warnOnce(msg) {\n    const isNodeProd = typeof process !== 'undefined' && process.env.NODE_ENV === 'production';\n    if (!isNodeProd && !false && !hasWarned[msg]) {\n        hasWarned[msg] = true;\n        warn(msg);\n    }\n}\nfunction warn(msg) {\n    console.warn(`\\x1b[1m\\x1b[33m[@vue/reactivity-transform]\\x1b[0m\\x1b[33m ${msg}\\x1b[0m\\n`);\n}\n\nexports.shouldTransform = shouldTransform;\nexports.transform = transform;\nexports.transformAST = transformAST;\n"]}